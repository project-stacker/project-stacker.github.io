{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"license/","text":"License \u00b6 Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [2017-2022] [Cisco Systems Inc] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"license/#license","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [2017-2022] [Cisco Systems Inc] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"concepts/incremental_build/","text":"Incremental Build \u00b6","title":"Incremental Build"},{"location":"concepts/incremental_build/#incremental-build","text":"","title":"Incremental Build"},{"location":"concepts/multi_layer_build/","text":"Multi-Layer Build \u00b6","title":"Multi-Layer Build"},{"location":"concepts/multi_layer_build/#multi-layer-build","text":"","title":"Multi-Layer Build"},{"location":"concepts/oci_image_layout/","text":"OCI Image Layout \u00b6","title":"OCI Image Layout"},{"location":"concepts/oci_image_layout/#oci-image-layout","text":"","title":"OCI Image Layout"},{"location":"concepts/squashfs_layer/","text":"Squashfs Layer \u00b6","title":"SquashFS Layer"},{"location":"concepts/squashfs_layer/#squashfs-layer","text":"","title":"Squashfs Layer"},{"location":"concepts/stacker_architecture/","text":"Stacker Architecture \u00b6","title":"Stacker Architecture"},{"location":"concepts/stacker_architecture/#stacker-architecture","text":"","title":"Stacker Architecture"},{"location":"developer_guide/building_stacker/","text":"Building and Installing Stacker \u00b6 Go Dependency \u00b6 Stacker requires at least go 1.11. Ubuntu 20.04 \u00b6 On Ubuntu 20.04 you can install Go using the instructions at: https://github.com/golang/go/wiki/Ubuntu Fedora 31 \u00b6 On Fedora 31 you can install Go with the following command: sudo dnf install golang Other Distributions \u00b6 If Go is not already packaged for your Linux distribution, you can get the latest Go version here: https://golang.org/dl/#stable Go can be installed using the instructions on on the official Go website: https://golang.org/doc/install#install Other Dependencies \u00b6 Ubuntu 20.04 \u00b6 The other build dependencies can be satisfied with the following command and packages: sudo apt install lxc-dev libacl1-dev libgpgme-dev libcap-dev libseccomp-dev sudo apt install libpam0g-dev libselinux-dev libssl-dev libzstd-dev libcryptsetup-dev libdevmapper-dev Ubuntu 22.04 \u00b6 sudo apt install lxc-dev libacl1-dev libgpgme-dev libcap-dev libseccomp-dev sudo apt install libpam0g-dev libselinux-dev libssl-dev libzstd-dev libcryptsetup-dev libdevmapper-dev cryptsetup-bin pkg-config libsquashfs1 libsquashfs-dev To run make check you will also need: sudo apt install bats jq tree umoci - https://github.com/opencontainers/umoci squashtool , but with a slightly different config than what is mentioned in the install guide (see below) - https://github.com/anuvu/squashfs Contrary to what the documentation in squashfs implies, squashtool and libsquash from squash-tools-ng need to be installed globally, as user specific path overrides aren't propagated into make check 's test envs. Thus, when you reach the step install into mylocal=\"$HOME/lib\" from the squashfs guide, use the config below. You can put them at the end of your .bashrc file so you don't need to run them every time. mylocal=\"/usr/local\" export LD_LIBRARY_PATH=$mylocal/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} export PKG_CONFIG_PATH=$mylocal/lib/pkgconfig${PKG_CONFIG_PATH:+:$PKG_CONFIG_PATH} Since the path /usr/local is owned by root, when you reach the step to run make install , you need to run it as sudo . make check requires the golangci-lint binary to be present in $GOPATH/bin Since there are some tests that run with elevated privileges and use git, it will complain that the stacker folder is unsafe as it is owned by your user. To prevent that, we need to tell git to consider that folder as safe. To do this, open your git config file ( .gitconfig ) and add the following line with the path to your local stacker folder. Below is an example: [safe] directory = /home/chofnar/github/stacker Fedora 31 \u00b6 The other build dependencies can be satisfied with the following command and packages: sudo dnf install lxc-devel libcap-devel libacl-devel gpgme-devel sudo dnf install bats jq Building the Stacker Binary \u00b6 Finally, once you have the build dependencies, stacker can be built with a simple make . The stacker binary will be output as ./stacker .","title":"Building Stacker"},{"location":"developer_guide/building_stacker/#building-and-installing-stacker","text":"","title":"Building and Installing Stacker"},{"location":"developer_guide/building_stacker/#go-dependency","text":"Stacker requires at least go 1.11.","title":"Go Dependency"},{"location":"developer_guide/building_stacker/#ubuntu-2004","text":"On Ubuntu 20.04 you can install Go using the instructions at: https://github.com/golang/go/wiki/Ubuntu","title":"Ubuntu 20.04"},{"location":"developer_guide/building_stacker/#fedora-31","text":"On Fedora 31 you can install Go with the following command: sudo dnf install golang","title":"Fedora 31"},{"location":"developer_guide/building_stacker/#other-distributions","text":"If Go is not already packaged for your Linux distribution, you can get the latest Go version here: https://golang.org/dl/#stable Go can be installed using the instructions on on the official Go website: https://golang.org/doc/install#install","title":"Other Distributions"},{"location":"developer_guide/building_stacker/#other-dependencies","text":"","title":"Other Dependencies"},{"location":"developer_guide/building_stacker/#ubuntu-2004_1","text":"The other build dependencies can be satisfied with the following command and packages: sudo apt install lxc-dev libacl1-dev libgpgme-dev libcap-dev libseccomp-dev sudo apt install libpam0g-dev libselinux-dev libssl-dev libzstd-dev libcryptsetup-dev libdevmapper-dev","title":"Ubuntu 20.04"},{"location":"developer_guide/building_stacker/#ubuntu-2204","text":"sudo apt install lxc-dev libacl1-dev libgpgme-dev libcap-dev libseccomp-dev sudo apt install libpam0g-dev libselinux-dev libssl-dev libzstd-dev libcryptsetup-dev libdevmapper-dev cryptsetup-bin pkg-config libsquashfs1 libsquashfs-dev To run make check you will also need: sudo apt install bats jq tree umoci - https://github.com/opencontainers/umoci squashtool , but with a slightly different config than what is mentioned in the install guide (see below) - https://github.com/anuvu/squashfs Contrary to what the documentation in squashfs implies, squashtool and libsquash from squash-tools-ng need to be installed globally, as user specific path overrides aren't propagated into make check 's test envs. Thus, when you reach the step install into mylocal=\"$HOME/lib\" from the squashfs guide, use the config below. You can put them at the end of your .bashrc file so you don't need to run them every time. mylocal=\"/usr/local\" export LD_LIBRARY_PATH=$mylocal/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} export PKG_CONFIG_PATH=$mylocal/lib/pkgconfig${PKG_CONFIG_PATH:+:$PKG_CONFIG_PATH} Since the path /usr/local is owned by root, when you reach the step to run make install , you need to run it as sudo . make check requires the golangci-lint binary to be present in $GOPATH/bin Since there are some tests that run with elevated privileges and use git, it will complain that the stacker folder is unsafe as it is owned by your user. To prevent that, we need to tell git to consider that folder as safe. To do this, open your git config file ( .gitconfig ) and add the following line with the path to your local stacker folder. Below is an example: [safe] directory = /home/chofnar/github/stacker","title":"Ubuntu 22.04"},{"location":"developer_guide/building_stacker/#fedora-31_1","text":"The other build dependencies can be satisfied with the following command and packages: sudo dnf install lxc-devel libcap-devel libacl-devel gpgme-devel sudo dnf install bats jq","title":"Fedora 31"},{"location":"developer_guide/building_stacker/#building-the-stacker-binary","text":"Finally, once you have the build dependencies, stacker can be built with a simple make . The stacker binary will be output as ./stacker .","title":"Building the Stacker Binary"},{"location":"developer_guide/code_structure/","text":"","title":"Code Structure"},{"location":"developer_guide/lxc_usage/","text":"","title":"LXC Usage"},{"location":"developer_guide/overlayfs_usage/","text":"","title":"OverlayFS Usage"},{"location":"get_started/build_image/","text":"Build Image \u00b6","title":"Build Image"},{"location":"get_started/build_image/#build-image","text":"","title":"Build Image"},{"location":"get_started/get_stacker/","text":"Stacker is a single static binary tool with most of the dependencies built into the binary. Stacker, however, depends on specific kernel capabilities and system tools to provide various features. Download Stacker wget https://github.com/project-stacker/stacker/releases/latest/download/stacker chmod +x ./stacker sudo cp ./stacker /usr/bin/stacker stacker --version stacker check Kernel dependencies \u00b6 Stacker requires overlayfs backend, and that works with any kernel >= 4.14. However, for unprivileged use, the overlayfs backend requires a reasonably new kernel change available on all kernels >= 5.8. Info Overlayfs kernel patches required for unprivileged use: vfs: allow unprivileged whiteout creation - a3c751a50fe6 ovl: unprivieged mounts - 459c7c565ac3 Some distributions may have ported these patches into older versions of their kernels. For example, Ubuntu 20.04 and 22.04 kernels already have these patches. Stacker has checks to ensure that it can run with all these environments requirements, and will fail fast if it can't do something it should be able to do. Stacker Check stacker check && echo \"stacker is ready to use!\" Overlay filesystem \u00b6 An underlying overlayfs cannot back stacker since the stacker needs to create whiteout files, and the kernel (rightfully) forbids manual creation of whiteout files on overlay filesystems. No additional userspace dependencies are required to use the overlayfs backend. Warning Do not use a overlayfs based filesystem as a storage for stacker root directory. Unprivileged setup \u00b6 Running stacker as an unprivileged user requires stacker to run inside a user namespace owned by the user that executed the command, and stacker will try to map 65k user and group ids to meet the POSIX standard. So, to run stacker, the user's /etc/sub{u,g}id should be configured with enough uids to map things correctly. This configuration can be done automatically via stacker unpriv-setup . Stacker unprivileged setup sudo stacker unpriv-setup cat /etc/subgid cat /etc/subuid Squashfs support \u00b6 In order to generate squashfs images, stacker invokes the mksquashfs binary. This binary needs to be installed and present in $PATH . Install mksquashfs on ubuntu sudo apt-get install -y squashfs-tools","title":"Get Stacker"},{"location":"get_started/get_stacker/#kernel-dependencies","text":"Stacker requires overlayfs backend, and that works with any kernel >= 4.14. However, for unprivileged use, the overlayfs backend requires a reasonably new kernel change available on all kernels >= 5.8. Info Overlayfs kernel patches required for unprivileged use: vfs: allow unprivileged whiteout creation - a3c751a50fe6 ovl: unprivieged mounts - 459c7c565ac3 Some distributions may have ported these patches into older versions of their kernels. For example, Ubuntu 20.04 and 22.04 kernels already have these patches. Stacker has checks to ensure that it can run with all these environments requirements, and will fail fast if it can't do something it should be able to do. Stacker Check stacker check && echo \"stacker is ready to use!\"","title":"Kernel dependencies"},{"location":"get_started/get_stacker/#overlay-filesystem","text":"An underlying overlayfs cannot back stacker since the stacker needs to create whiteout files, and the kernel (rightfully) forbids manual creation of whiteout files on overlay filesystems. No additional userspace dependencies are required to use the overlayfs backend. Warning Do not use a overlayfs based filesystem as a storage for stacker root directory.","title":"Overlay filesystem"},{"location":"get_started/get_stacker/#unprivileged-setup","text":"Running stacker as an unprivileged user requires stacker to run inside a user namespace owned by the user that executed the command, and stacker will try to map 65k user and group ids to meet the POSIX standard. So, to run stacker, the user's /etc/sub{u,g}id should be configured with enough uids to map things correctly. This configuration can be done automatically via stacker unpriv-setup . Stacker unprivileged setup sudo stacker unpriv-setup cat /etc/subgid cat /etc/subuid","title":"Unprivileged setup"},{"location":"get_started/get_stacker/#squashfs-support","text":"In order to generate squashfs images, stacker invokes the mksquashfs binary. This binary needs to be installed and present in $PATH . Install mksquashfs on ubuntu sudo apt-get install -y squashfs-tools","title":"Squashfs support"},{"location":"reference/stacker_cli/","text":"Stacker CLI \u00b6","title":"Stacker CLI"},{"location":"reference/stacker_cli/#stacker-cli","text":"","title":"Stacker CLI"},{"location":"reference/stacker_file/","text":"The stacker.yaml file \u00b6 When doing a stacker build , the behavior of stacker is specified by the yaml directives below. In addition to these, stacker allows variable substitions of several forms. For example, a line like: $ONE ${{TWO}} ${{THREE:3}} When run with stacker build --substitute ONE=1 --substitute TWO=2 is processed in stacker as: 1 2 3 That is, variables of the form $FOO or ${FOO} are supported, and variables with ${FOO:default} a default value will evaluate to their default if not specified on the command line. It is an error to specify a ${FOO} style without a default; to make the default an empty string, use ${FOO:} . In addition to substitutions provided on the command line, the following variables are also available with their values from either command line flags or stacker-config file. STACKER_STACKER_DIR config name 'stacker_dir', cli flag '--stacker-dir'- STACKER_ROOTFS_DIR config name 'rootfs_dir', cli flag '--roots-dir' STACKER_OCI_DIR config name 'oci_dir', cli flag '--oci-dir' The stacker build environment will have the following environment variables available for reference: STACKER_LAYER_NAME : the name of the layer being built. STACKER_LAYER_NAME will be my-build when the run section below is executed. my-build : run : echo \"Your layer is ${STACKER_LAYER_NAME}\" from \u00b6 The from directive describes the base image that stacker will start from. It takes the form: from: type: $type url: $url tag: $tag insecure: true Some directives are irrelevant depending on the type. Supported types are: docker : url is required, insecure is optional. When insecure is specified, stacker attempts to connect via http instead of https to the Docker Hub. tar : url is required, everything else is ignored. oci : url is required, of the form path:tag . This uses the OCI image at url (which may be a local path). built : tag is required, everything else is ignored. built bases this layer on a previously specified layer in the stacker file. import \u00b6 The import directive describes what files should be made available in /stacker during the run phase. There are three forms of importing supported today: /path/to/file Will import a file or directory from the local filesystem. If the file or directory changes between stacker builds, it will be hashed and the new file will be imported on subsequent builds. http://example.com/foo.tar.gz Will import foo.tar.gz and make it available in /stacker . Note that stacker will NOT update this file unless the cache is cleared, to avoid excess network usage. That means that updates after the first time stacker downloads the file will not be reflected. stacker://$name/path/to/file Will grab /path/to/file from the previously built layer $name . import hash \u00b6 The import directive also supports specifying the hash(sha256sum) of import source, for all the three forms presented above, for example: import: - path: config.json hash: f55af805b012017bc.... - path: http://example.com/foo.tar.gz hash: b458dfd63e7883a64.... - path: stacker://$name/path/to/file hash: f805b012017bc769a.... Before copying the file it will check if the requested hash matches the actual one. stacker build supports the flag --require-flag which checks that all http(s) remote imports have an hash in all stacker YAMLs. This new import mode can be combined with the old one, for example: import: - path: \"config.json hash: \"BEEFcafeaaaaAAAA....\" - /path/to/file overlay_dirs \u00b6 This directive works only with OverlayFS backend storage. The overlay_dirs directive describes what directories (content) from the host should be available in the container's filesystem. It preserves all file/dirs attributes but no owner or group. overlay_dirs: - source: /path/to/directory dest: /usr/local/ ## optional arg, default is '/' - source: /path/to/directory2 This example will result in all the files/dirs from the host's /path/to/directory to be available under container's /usr/local/ and all the files/dirs from the host's /path/to/directory2 to be available under container's / environment , labels , working_dir , volumes , cmd , entrypoint , user \u00b6 These all correspond exactly to the similarly named bits in the OCI image config spec , and are available for users to pass things through to the runtime environment of the image. generate_labels \u00b6 The generate_labels entry is similar to run in that it contains a list of commands to run inside the generated rootfs. It runs after the run section is done, and its mutations to the filesystem are not recorded, except in one case /oci-labels . /oci-labels is a special directory where this code can write a file, and the name of the file will be the OCI label name, and the content will be the label content. build_env and build_env_passthrough \u00b6 By default, environment variables do not pass through (pollute) the build environment. build_env : this is a dictionary with environment variable definitions. their values will be present in the build's environment. build_env_passthrough : This is a list of regular expressions that work as a filter on which environment variables should be passed through from the current env into the container. To let all variables through simply set build_env_passthrough : [\".*\"] If build_env_passthrough is not set, then the default value is to allow through proxy variables HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, http_proxy, https_proxy, ftp_proxy . Values in the build_env override values passed through via full_command \u00b6 Because of the odd behavior of cmd and entrypoint (and the inherited nature of these from previous stacker layers), full_command provides a way to set the full command that will be executed in the image, clearing out any previous cmd and entrypoint values that were set in the image. build_only \u00b6 build_only : indicates whether or not to include this layer in the final OCI image. This can be useful in conjunction with an import from this layer in another image, if you want to isolate the build environment for a binary but not include all of its build dependencies. binds \u00b6 binds : specifies bind mounts from the host to the container. There are two formats: binds: - /foo/bar -> /bar/baz - /zomg The first one binds /foo/bar to /bar/baz, and the second host /zomg to container /zomg. Right now there is no awareness of change for any of these bind mounts, so --no-cache should be used to re-build if the content of the bind mount has changed. config \u00b6 config key is a special type of entry in the root in the stacker.yaml file. It cannot contain a layer definition, it is used to provide configuration applicable for building all the layers defined in this file. For example, config: prerequisites: - ../folder2/stacker.yaml - ../folder3/stacker.yaml prerequisites \u00b6 If the prerequisites list is present under the config key, stacker will make sure to build all the layers in the stacker.yaml files found at the paths contained in the list. This way stacker supports building multiple stacker.yaml files in the correct order. In this particular case the parent folder of the current folder, let's call it parent , has 3 subfolders folder1 , folder2 and folder3 , each containing a stacker.yaml file. The example config above is in parent/folder1/stacker.yaml . When stacker build -f parent/folder1/stacker.yaml is invoked, stacker would search for the other two stacker.yaml files and build them first, before building the stacker.yaml specified in the command line. annotations \u00b6 annotations is a user-specified key value map that will be included in the final OCI image. Note that these annotations are included in the image manifest itself and not as part of the index.json. annotations: a.b.c.key: abc_val p.q.r.key: pqr_val While config section supports a similar labels , it is more pertitent to the image runtime. On the other hand, annotations is intended to be image-specific metadata aligned with the annotations in the image spec .","title":"Stacker File"},{"location":"reference/stacker_file/#the-stackeryaml-file","text":"When doing a stacker build , the behavior of stacker is specified by the yaml directives below. In addition to these, stacker allows variable substitions of several forms. For example, a line like: $ONE ${{TWO}} ${{THREE:3}} When run with stacker build --substitute ONE=1 --substitute TWO=2 is processed in stacker as: 1 2 3 That is, variables of the form $FOO or ${FOO} are supported, and variables with ${FOO:default} a default value will evaluate to their default if not specified on the command line. It is an error to specify a ${FOO} style without a default; to make the default an empty string, use ${FOO:} . In addition to substitutions provided on the command line, the following variables are also available with their values from either command line flags or stacker-config file. STACKER_STACKER_DIR config name 'stacker_dir', cli flag '--stacker-dir'- STACKER_ROOTFS_DIR config name 'rootfs_dir', cli flag '--roots-dir' STACKER_OCI_DIR config name 'oci_dir', cli flag '--oci-dir' The stacker build environment will have the following environment variables available for reference: STACKER_LAYER_NAME : the name of the layer being built. STACKER_LAYER_NAME will be my-build when the run section below is executed. my-build : run : echo \"Your layer is ${STACKER_LAYER_NAME}\"","title":"The stacker.yaml file"},{"location":"reference/stacker_file/#from","text":"The from directive describes the base image that stacker will start from. It takes the form: from: type: $type url: $url tag: $tag insecure: true Some directives are irrelevant depending on the type. Supported types are: docker : url is required, insecure is optional. When insecure is specified, stacker attempts to connect via http instead of https to the Docker Hub. tar : url is required, everything else is ignored. oci : url is required, of the form path:tag . This uses the OCI image at url (which may be a local path). built : tag is required, everything else is ignored. built bases this layer on a previously specified layer in the stacker file.","title":"from"},{"location":"reference/stacker_file/#import","text":"The import directive describes what files should be made available in /stacker during the run phase. There are three forms of importing supported today: /path/to/file Will import a file or directory from the local filesystem. If the file or directory changes between stacker builds, it will be hashed and the new file will be imported on subsequent builds. http://example.com/foo.tar.gz Will import foo.tar.gz and make it available in /stacker . Note that stacker will NOT update this file unless the cache is cleared, to avoid excess network usage. That means that updates after the first time stacker downloads the file will not be reflected. stacker://$name/path/to/file Will grab /path/to/file from the previously built layer $name .","title":"import"},{"location":"reference/stacker_file/#import-hash","text":"The import directive also supports specifying the hash(sha256sum) of import source, for all the three forms presented above, for example: import: - path: config.json hash: f55af805b012017bc.... - path: http://example.com/foo.tar.gz hash: b458dfd63e7883a64.... - path: stacker://$name/path/to/file hash: f805b012017bc769a.... Before copying the file it will check if the requested hash matches the actual one. stacker build supports the flag --require-flag which checks that all http(s) remote imports have an hash in all stacker YAMLs. This new import mode can be combined with the old one, for example: import: - path: \"config.json hash: \"BEEFcafeaaaaAAAA....\" - /path/to/file","title":"import hash"},{"location":"reference/stacker_file/#overlay_dirs","text":"This directive works only with OverlayFS backend storage. The overlay_dirs directive describes what directories (content) from the host should be available in the container's filesystem. It preserves all file/dirs attributes but no owner or group. overlay_dirs: - source: /path/to/directory dest: /usr/local/ ## optional arg, default is '/' - source: /path/to/directory2 This example will result in all the files/dirs from the host's /path/to/directory to be available under container's /usr/local/ and all the files/dirs from the host's /path/to/directory2 to be available under container's /","title":"overlay_dirs"},{"location":"reference/stacker_file/#environment-labels-working_dir-volumes-cmd-entrypoint-user","text":"These all correspond exactly to the similarly named bits in the OCI image config spec , and are available for users to pass things through to the runtime environment of the image.","title":"environment, labels, working_dir, volumes, cmd, entrypoint, user"},{"location":"reference/stacker_file/#generate_labels","text":"The generate_labels entry is similar to run in that it contains a list of commands to run inside the generated rootfs. It runs after the run section is done, and its mutations to the filesystem are not recorded, except in one case /oci-labels . /oci-labels is a special directory where this code can write a file, and the name of the file will be the OCI label name, and the content will be the label content.","title":"generate_labels"},{"location":"reference/stacker_file/#build_env-and-build_env_passthrough","text":"By default, environment variables do not pass through (pollute) the build environment. build_env : this is a dictionary with environment variable definitions. their values will be present in the build's environment. build_env_passthrough : This is a list of regular expressions that work as a filter on which environment variables should be passed through from the current env into the container. To let all variables through simply set build_env_passthrough : [\".*\"] If build_env_passthrough is not set, then the default value is to allow through proxy variables HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, http_proxy, https_proxy, ftp_proxy . Values in the build_env override values passed through via","title":"build_env and build_env_passthrough"},{"location":"reference/stacker_file/#full_command","text":"Because of the odd behavior of cmd and entrypoint (and the inherited nature of these from previous stacker layers), full_command provides a way to set the full command that will be executed in the image, clearing out any previous cmd and entrypoint values that were set in the image.","title":"full_command"},{"location":"reference/stacker_file/#build_only","text":"build_only : indicates whether or not to include this layer in the final OCI image. This can be useful in conjunction with an import from this layer in another image, if you want to isolate the build environment for a binary but not include all of its build dependencies.","title":"build_only"},{"location":"reference/stacker_file/#binds","text":"binds : specifies bind mounts from the host to the container. There are two formats: binds: - /foo/bar -> /bar/baz - /zomg The first one binds /foo/bar to /bar/baz, and the second host /zomg to container /zomg. Right now there is no awareness of change for any of these bind mounts, so --no-cache should be used to re-build if the content of the bind mount has changed.","title":"binds"},{"location":"reference/stacker_file/#config","text":"config key is a special type of entry in the root in the stacker.yaml file. It cannot contain a layer definition, it is used to provide configuration applicable for building all the layers defined in this file. For example, config: prerequisites: - ../folder2/stacker.yaml - ../folder3/stacker.yaml","title":"config"},{"location":"reference/stacker_file/#prerequisites","text":"If the prerequisites list is present under the config key, stacker will make sure to build all the layers in the stacker.yaml files found at the paths contained in the list. This way stacker supports building multiple stacker.yaml files in the correct order. In this particular case the parent folder of the current folder, let's call it parent , has 3 subfolders folder1 , folder2 and folder3 , each containing a stacker.yaml file. The example config above is in parent/folder1/stacker.yaml . When stacker build -f parent/folder1/stacker.yaml is invoked, stacker would search for the other two stacker.yaml files and build them first, before building the stacker.yaml specified in the command line.","title":"prerequisites"},{"location":"reference/stacker_file/#annotations","text":"annotations is a user-specified key value map that will be included in the final OCI image. Note that these annotations are included in the image manifest itself and not as part of the index.json. annotations: a.b.c.key: abc_val p.q.r.key: pqr_val While config section supports a similar labels , it is more pertitent to the image runtime. On the other hand, annotations is intended to be image-specific metadata aligned with the annotations in the image spec .","title":"annotations"},{"location":"user_guide/annotation_support/","text":"","title":"Annotation Support"},{"location":"user_guide/build_cache/","text":"","title":"Build Cache"},{"location":"user_guide/debugging/","text":"Debugging Stacker \u00b6 The first step to trying to find a bug in stacker is to run it with --debug. This will give you a stack trace from where (at least in stacker's code) the error originated via github.com/pkg/errors . Sometimes it is useful to write a small reproducer in test/ , and run it with: make check TEST=myreproducer.bats Overlayfs / layer issues \u00b6 Another thing --debug will show you is what overlay arguments it is sending to LXC. Note that the build overlay filesystem never exists in the host mount namespace, but is created by liblxc in the child namespace. Sometimes it can be useful to take these overlay args and split up the lowerdirs: /data/ssd/builds/stacker/stacker_layers/.roots/sha256_f8e46c301da6347e78057d8fe48a6bbd8fc0cab213d47825f5c0c0646f542b6b/overlay /data/ssd/builds/stacker/stacker_layers/.roots/sha256_7eb8e296d351fe6d0c87fea979b305e2b1f19548d99f9aee4b8030b596f02efd/overlay /data/ssd/builds/stacker/stacker_layers/.roots/sha256_ca379e914166030218007477a7b9cfd0ca3dd554c58e2401c58c634fac9182f8/overlay and look through each one (top to bottom, as the overlay stack would present) in order to see what's going on. Debugging LXC \u00b6 If things are really bad, you may end up wading through liblxc. With --debug , stacker will also try and render any liblxc ERRORs to stdout, but sometimes it can be useful to see a full liblxc trace log. This is available in $(--stacker-dir)/lxc.log for the last run. If you get even more in the weeds, you may need to build your own liblxc with debug statements. Thankfully, everything is statically linked so this is fairly easy to test locally, as long as your host liblxc can build stacker: make LXC_CLONE_URL=https://github.com/tych0/lxc LXC_BRANCH=my-debug-branch Stacker links against this through a convoluted mechanism: it builds a static C program in /cmd/lxc-wrapper/ that takes a few relevant arguments about what mode to drive liblxc in. Stacker uses the go-embed mechanism to embed the resulting statically linked binary, and then resolves and execs it at runtime via the code in /embed-exec . The reason for all this indirection vs. linking against something directly is that the kernel does not allow multithreaded programs to unshare user namespaces. Since the go runtime spawns many threads for GC and various other tasks, go code cannot directly unshare a user namespace (one wonders, then, why this was the language chosen for runc, lxd, etc...). A previous implementation (the one in lxd) was to use some __attribute__((constructor)) nonsense and hope for the best, but it doesn't work in all cases, and go-embed allows for librar-ization of stacker code if someone else wants to use it eventually. See 8fa336834f31 (\"container: move to go-embed for re-exec of C code\") for details on that approach. Overlay storage layout \u00b6 The storage parent directory is whatever is specified to stacker via --roots-dir . Each layer is extracted into a sha256_$hash/overlay directory, which is then sewn together via overlayfs. At the top level, for a layer called foo , there are two directories: foo/rootfs , and foo/overlay . During the build, foo 's rootfs is mounted inside the container as foo/rootfs , with the overlay upperdir=foo/overlay . This way, whatever filesystem mutations the foo layer's run: section performs end up in foo/overlay . After the run: section, stacker generates whatever layers the user requested from this, creates sha256_$hash/overlay dirs with the contents (if two layer types were converted, then the hash of the squashfs output will just be a symlink to the tar layer's directory to save space), and foo/overlay_metadata.json will be updated to reflect these new outputs, for use when e.g. foo is a dependency of some other layer bar . Note that there is currently one wart. In a stacker file like: foo: from: type: docker url: docker://ubuntu:latest build_only: true run: | dd if=/dev/random of=/bigfile bs=1M count=1000 bar: from: type: bult tag: foo run: | rm /bigfile The final image for bar will actually contain a layer with /bigfile in it, because the foo layer's mutations are generated independently of bar 's. Some clever userspace overlay collapsing could be done here to remove this wart, though.","title":"Debugging"},{"location":"user_guide/debugging/#debugging-stacker","text":"The first step to trying to find a bug in stacker is to run it with --debug. This will give you a stack trace from where (at least in stacker's code) the error originated via github.com/pkg/errors . Sometimes it is useful to write a small reproducer in test/ , and run it with: make check TEST=myreproducer.bats","title":"Debugging Stacker"},{"location":"user_guide/debugging/#overlayfs-layer-issues","text":"Another thing --debug will show you is what overlay arguments it is sending to LXC. Note that the build overlay filesystem never exists in the host mount namespace, but is created by liblxc in the child namespace. Sometimes it can be useful to take these overlay args and split up the lowerdirs: /data/ssd/builds/stacker/stacker_layers/.roots/sha256_f8e46c301da6347e78057d8fe48a6bbd8fc0cab213d47825f5c0c0646f542b6b/overlay /data/ssd/builds/stacker/stacker_layers/.roots/sha256_7eb8e296d351fe6d0c87fea979b305e2b1f19548d99f9aee4b8030b596f02efd/overlay /data/ssd/builds/stacker/stacker_layers/.roots/sha256_ca379e914166030218007477a7b9cfd0ca3dd554c58e2401c58c634fac9182f8/overlay and look through each one (top to bottom, as the overlay stack would present) in order to see what's going on.","title":"Overlayfs / layer issues"},{"location":"user_guide/debugging/#debugging-lxc","text":"If things are really bad, you may end up wading through liblxc. With --debug , stacker will also try and render any liblxc ERRORs to stdout, but sometimes it can be useful to see a full liblxc trace log. This is available in $(--stacker-dir)/lxc.log for the last run. If you get even more in the weeds, you may need to build your own liblxc with debug statements. Thankfully, everything is statically linked so this is fairly easy to test locally, as long as your host liblxc can build stacker: make LXC_CLONE_URL=https://github.com/tych0/lxc LXC_BRANCH=my-debug-branch Stacker links against this through a convoluted mechanism: it builds a static C program in /cmd/lxc-wrapper/ that takes a few relevant arguments about what mode to drive liblxc in. Stacker uses the go-embed mechanism to embed the resulting statically linked binary, and then resolves and execs it at runtime via the code in /embed-exec . The reason for all this indirection vs. linking against something directly is that the kernel does not allow multithreaded programs to unshare user namespaces. Since the go runtime spawns many threads for GC and various other tasks, go code cannot directly unshare a user namespace (one wonders, then, why this was the language chosen for runc, lxd, etc...). A previous implementation (the one in lxd) was to use some __attribute__((constructor)) nonsense and hope for the best, but it doesn't work in all cases, and go-embed allows for librar-ization of stacker code if someone else wants to use it eventually. See 8fa336834f31 (\"container: move to go-embed for re-exec of C code\") for details on that approach.","title":"Debugging LXC"},{"location":"user_guide/debugging/#overlay-storage-layout","text":"The storage parent directory is whatever is specified to stacker via --roots-dir . Each layer is extracted into a sha256_$hash/overlay directory, which is then sewn together via overlayfs. At the top level, for a layer called foo , there are two directories: foo/rootfs , and foo/overlay . During the build, foo 's rootfs is mounted inside the container as foo/rootfs , with the overlay upperdir=foo/overlay . This way, whatever filesystem mutations the foo layer's run: section performs end up in foo/overlay . After the run: section, stacker generates whatever layers the user requested from this, creates sha256_$hash/overlay dirs with the contents (if two layer types were converted, then the hash of the squashfs output will just be a symlink to the tar layer's directory to save space), and foo/overlay_metadata.json will be updated to reflect these new outputs, for use when e.g. foo is a dependency of some other layer bar . Note that there is currently one wart. In a stacker file like: foo: from: type: docker url: docker://ubuntu:latest build_only: true run: | dd if=/dev/random of=/bigfile bs=1M count=1000 bar: from: type: bult tag: foo run: | rm /bigfile The final image for bar will actually contain a layer with /bigfile in it, because the foo layer's mutations are generated independently of bar 's. Some clever userspace overlay collapsing could be done here to remove this wart, though.","title":"Overlay storage layout"},{"location":"user_guide/dependency_builds/","text":"","title":"Dependency Builds"},{"location":"user_guide/grab_image_content/","text":"","title":"Grab Image Content"},{"location":"user_guide/image_build/","text":"Image Build \u00b6 Stacker is a tool that allows for building OCI images in a reproducible manner, completely unprivileged. For this tutorial, we assume you have followed the Get Stacker guide. First stacker.yaml \u00b6 The basic input to stacker is the stacker.yaml file, which describes what the base for your OCI image should be, and what to do to construct it. One of the smallest stacker files is just: first: from: type: docker url: docker://centos:latest Note the key first represents the name of the layer, and it can have any value except config , which has a special usage, see the stacker file documentation. With this stacker file as first.yaml , we can do a basic stacker build: $ stacker build -f first.yaml building image first... importing files... Getting image source signatures Copying blob sha256:5e35d10a3ebadf9d6ab606ce72e1e77f8646b2e2ff8dd3a60d4401c3e3a76f31 69.60 MB / 69.60 MB [=====================================================] 16s Copying config sha256:44a17ce607dadfb71de41d82c75d756c2bca4db677bba99969f28de726e4411e 862 B / 862 B [============================================================] 0s Writing manifest to image destination Storing signatures unpacking to /home/ubuntu/tutorial/roots/_working running commands... generating layer... filesystem first built successfully What happened here is that stacker downloaded the centos:latest tag from the docker hub and generated it as an OCI image with tag \"first\". We can verify this: $ umoci ls --layout oci centos-latest first The centos-latest there is the OCI tag for the base image, and first is the image we generated. The next thing to note is that if we do another rebuild, less things happen: $ stacker build -f first.yaml building image first... importing files... found cached layer first Stacker will cache all of the inputs to stacker files, and only rebuild when one of them changes. The cache (and all of stacker's metadata) live in the .stacker directory where you run stacker from. Stacker's metadata can be cleaned with stacker clean , and its entire cache can be removed with stacker clean . So far, the only input is a base image, but what about if we want to import a script to run or a config file? Consider the next example: first: from: type: docker url: docker://centos:latest import: - config.json - install.sh run: | mkdir -p /etc/myapp cp /stacker/config.json /etc/myapp/ /stacker/install.sh If the content of install.sh is just echo hello world , then stacker's output will look something like: $ stacker build -f first.yaml building image first... importing files... copying config.json copying install.sh Getting image source signatures Skipping fetch of repeat blob sha256:5e35d10a3ebadf9d6ab606ce72e1e77f8646b2e2ff8dd3a60d4401c3e3a76f31 Copying config sha256:44a17ce607dadfb71de41d82c75d756c2bca4db677bba99969f28de726e4411e 862 B / 862 B [============================================================] 0s Writing manifest to image destination Storing signatures unpacking to /home/ubuntu/tutorial/roots/_working running commands... running commands for first + mkdir -p /etc/myapp + cp /stacker/config.json /etc/myapp + /stacker/install.sh hello world generating layer... filesystem first built successfully There are two new stacker file directives here: import: - config.json - install.sh Which imports those two files into the /stacker directory inside the image. This directory will not be present during the final image, so copy any files you need out of it into their final place in the image. Also, importing things from the web (via http://example.com/foo.tar.gz urls) is supported, and these things will be cached on disk. Stacker will not evaluate as long as it has a file there, so if something at the URL changes, you need to run stacker build with the --no-cache argument, or simply delete the file from .stacker/imports/$target_name/foo.tar.gz . And then there is: run: | mkdir -p /etc/myapp cp /stacker/config.json /etc/myapp/ /stacker/install.sh Which is the set of commands to run in order to install and configure the image. Also note that it used a cached version of the base layer, but then re-built the part where you asked for commands to be run, since that is new. dev/build containers \u00b6 Finally, stacker offers \"build only\" containers, which are just built, but not emitted in the final OCI image. For example: build: from: type: docker url: docker://ubuntu:latest run: | apt update apt install -y software-properties-common git apt-add-repository -y ppa:gophers/archive apt update apt install -y golang-1.9 export PATH=$PATH:/usr/lib/go-1.9/bin export GOPATH=~/go mkdir -p $GOPATH/src/github.com/openSUSE cd $GOPATH/src/github.com/openSUSE git clone https://github.com/opencontainers/umoci cd umoci make umoci.static cp umoci.static / build_only: true umoci: from: type: docker url: docker://centos:latest import: stacker://build/umoci.static run: cp /stacker/umoci.static /usr/bin/umoci Will build a static version of umoci in an ubuntu container, but the final image will only contain an umoci tag with a statically linked version of umoci at /usr/bin/umoci . There are a few new directives to support this: build_only: true indicates that the container shouldn't be emitted in the final image, because we're going to import something from it and don't need the rest of it. The line: import: stacker://build/umoci.static is what actually does this import, and it says \"from a previously built stacker image called 'build', import /umoci.static\".","title":"Image Build"},{"location":"user_guide/image_build/#image-build","text":"Stacker is a tool that allows for building OCI images in a reproducible manner, completely unprivileged. For this tutorial, we assume you have followed the Get Stacker guide.","title":"Image Build"},{"location":"user_guide/image_build/#first-stackeryaml","text":"The basic input to stacker is the stacker.yaml file, which describes what the base for your OCI image should be, and what to do to construct it. One of the smallest stacker files is just: first: from: type: docker url: docker://centos:latest Note the key first represents the name of the layer, and it can have any value except config , which has a special usage, see the stacker file documentation. With this stacker file as first.yaml , we can do a basic stacker build: $ stacker build -f first.yaml building image first... importing files... Getting image source signatures Copying blob sha256:5e35d10a3ebadf9d6ab606ce72e1e77f8646b2e2ff8dd3a60d4401c3e3a76f31 69.60 MB / 69.60 MB [=====================================================] 16s Copying config sha256:44a17ce607dadfb71de41d82c75d756c2bca4db677bba99969f28de726e4411e 862 B / 862 B [============================================================] 0s Writing manifest to image destination Storing signatures unpacking to /home/ubuntu/tutorial/roots/_working running commands... generating layer... filesystem first built successfully What happened here is that stacker downloaded the centos:latest tag from the docker hub and generated it as an OCI image with tag \"first\". We can verify this: $ umoci ls --layout oci centos-latest first The centos-latest there is the OCI tag for the base image, and first is the image we generated. The next thing to note is that if we do another rebuild, less things happen: $ stacker build -f first.yaml building image first... importing files... found cached layer first Stacker will cache all of the inputs to stacker files, and only rebuild when one of them changes. The cache (and all of stacker's metadata) live in the .stacker directory where you run stacker from. Stacker's metadata can be cleaned with stacker clean , and its entire cache can be removed with stacker clean . So far, the only input is a base image, but what about if we want to import a script to run or a config file? Consider the next example: first: from: type: docker url: docker://centos:latest import: - config.json - install.sh run: | mkdir -p /etc/myapp cp /stacker/config.json /etc/myapp/ /stacker/install.sh If the content of install.sh is just echo hello world , then stacker's output will look something like: $ stacker build -f first.yaml building image first... importing files... copying config.json copying install.sh Getting image source signatures Skipping fetch of repeat blob sha256:5e35d10a3ebadf9d6ab606ce72e1e77f8646b2e2ff8dd3a60d4401c3e3a76f31 Copying config sha256:44a17ce607dadfb71de41d82c75d756c2bca4db677bba99969f28de726e4411e 862 B / 862 B [============================================================] 0s Writing manifest to image destination Storing signatures unpacking to /home/ubuntu/tutorial/roots/_working running commands... running commands for first + mkdir -p /etc/myapp + cp /stacker/config.json /etc/myapp + /stacker/install.sh hello world generating layer... filesystem first built successfully There are two new stacker file directives here: import: - config.json - install.sh Which imports those two files into the /stacker directory inside the image. This directory will not be present during the final image, so copy any files you need out of it into their final place in the image. Also, importing things from the web (via http://example.com/foo.tar.gz urls) is supported, and these things will be cached on disk. Stacker will not evaluate as long as it has a file there, so if something at the URL changes, you need to run stacker build with the --no-cache argument, or simply delete the file from .stacker/imports/$target_name/foo.tar.gz . And then there is: run: | mkdir -p /etc/myapp cp /stacker/config.json /etc/myapp/ /stacker/install.sh Which is the set of commands to run in order to install and configure the image. Also note that it used a cached version of the base layer, but then re-built the part where you asked for commands to be run, since that is new.","title":"First stacker.yaml"},{"location":"user_guide/image_build/#devbuild-containers","text":"Finally, stacker offers \"build only\" containers, which are just built, but not emitted in the final OCI image. For example: build: from: type: docker url: docker://ubuntu:latest run: | apt update apt install -y software-properties-common git apt-add-repository -y ppa:gophers/archive apt update apt install -y golang-1.9 export PATH=$PATH:/usr/lib/go-1.9/bin export GOPATH=~/go mkdir -p $GOPATH/src/github.com/openSUSE cd $GOPATH/src/github.com/openSUSE git clone https://github.com/opencontainers/umoci cd umoci make umoci.static cp umoci.static / build_only: true umoci: from: type: docker url: docker://centos:latest import: stacker://build/umoci.static run: cp /stacker/umoci.static /usr/bin/umoci Will build a static version of umoci in an ubuntu container, but the final image will only contain an umoci tag with a statically linked version of umoci at /usr/bin/umoci . There are a few new directives to support this: build_only: true indicates that the container shouldn't be emitted in the final image, because we're going to import something from it and don't need the rest of it. The line: import: stacker://build/umoci.static is what actually does this import, and it says \"from a previously built stacker image called 'build', import /umoci.static\".","title":"dev/build containers"},{"location":"user_guide/image_chroot/","text":"","title":"Image Chroot"},{"location":"user_guide/inspect_images/","text":"","title":"Inspect Images"},{"location":"user_guide/publish_images/","text":"","title":"Publish Images"},{"location":"user_guide/runtime_environment/","text":"","title":"Runtime Environment"},{"location":"user_guide/scratch_image/","text":"Building container image from scratch \u00b6 There are a couple of cases where it may be useful to build a layer from scratch. For example to derive a new base install of an OS or to build a \"tarball\" type image which just carries data and will not actually be run by a container runtime. The way to accomplish this in stacker is to use a build only layer (i.e. a layer that does not get emitted into the final OCI image, perhaps containing assets or something that will be used by the final container). The best way to accomplish this is as follows: build: from: type: docker url: docker://ubuntu:latest run: | touch /tmp/first touch /tmp/second tar -C /tmp -cv -f /contents.tar first second build_only: true contents: from: type: tar url: stacker://build/contents.tar Or e.g. to bootstrap a base layer for CentoOS 7: build: from: type: docker url: docker://ubuntu:latest run: | yum -y --installroot=/rootfs --nogpgcheck install tar -C rootfs -zcf /rootfs.tar . build_only: true contents: from: type: tar url: stacker://build/rootfs.tar These work by creating the base for the system in a build container with all the utilities available needed to manipulate that base, and then asking stacker to create a layer based on this tarball, without actually running anything inside of the layer (which means e.g. absence of a shell or libc or whatever is fine). Another way to accomplish something similar is to use a distroless layer: build: from: type: docker url: docker://ubuntu:latest binds: - /tmp/dir_to_overlay -> /dir_to_overlay run: | touch /dir_to_overlay/binaryfile build_only: true contents: from: type: docker url: docker://zothub.io/project-stacker/c3/base overlay_dirs: - source: /tmp/dir_to_overlay dest: /dir_to_overlay You can use the first layer as a build env, and copy your binary to a bind-mounted folder. Use overlay_dirs with that same folder to have the binary in the distroless layer.","title":"Scratch Image"},{"location":"user_guide/scratch_image/#building-container-image-from-scratch","text":"There are a couple of cases where it may be useful to build a layer from scratch. For example to derive a new base install of an OS or to build a \"tarball\" type image which just carries data and will not actually be run by a container runtime. The way to accomplish this in stacker is to use a build only layer (i.e. a layer that does not get emitted into the final OCI image, perhaps containing assets or something that will be used by the final container). The best way to accomplish this is as follows: build: from: type: docker url: docker://ubuntu:latest run: | touch /tmp/first touch /tmp/second tar -C /tmp -cv -f /contents.tar first second build_only: true contents: from: type: tar url: stacker://build/contents.tar Or e.g. to bootstrap a base layer for CentoOS 7: build: from: type: docker url: docker://ubuntu:latest run: | yum -y --installroot=/rootfs --nogpgcheck install tar -C rootfs -zcf /rootfs.tar . build_only: true contents: from: type: tar url: stacker://build/rootfs.tar These work by creating the base for the system in a build container with all the utilities available needed to manipulate that base, and then asking stacker to create a layer based on this tarball, without actually running anything inside of the layer (which means e.g. absence of a shell or libc or whatever is fine). Another way to accomplish something similar is to use a distroless layer: build: from: type: docker url: docker://ubuntu:latest binds: - /tmp/dir_to_overlay -> /dir_to_overlay run: | touch /dir_to_overlay/binaryfile build_only: true contents: from: type: docker url: docker://zothub.io/project-stacker/c3/base overlay_dirs: - source: /tmp/dir_to_overlay dest: /dir_to_overlay You can use the first layer as a build env, and copy your binary to a bind-mounted folder. Use overlay_dirs with that same folder to have the binary in the distroless layer.","title":"Building container image from scratch"},{"location":"user_guide/squashfs_images/","text":"","title":"SquashFS Images"},{"location":"user_guide/templates/","text":"","title":"Templates"}]}