{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"features/","title":"Features","text":"<p>The key features of <code>stacker</code> are:</p>"},{"location":"features/#single-binary","title":"Single Binary","text":"<p>One statically built binary for simplified download and installation with no additional dependencies or services.</p>"},{"location":"features/#unprivileged","title":"Unprivileged","text":"<p>Build using user namespaces and avoid privileges on host.</p>"},{"location":"features/#repeatable","title":"Repeatable","text":"<p>Hermetically sealed environment for image builds using LXC containers so that builds are repeatable without side-effects.</p>"},{"location":"features/#incremental","title":"Incremental","text":"<p>Build only the images necessary and rebuild only if any input changed.</p>"},{"location":"features/#open-source","title":"Open source","text":"<p>Released as an open source project under Apache2 License.</p>"},{"location":"features/#github-action","title":"GitHub Action","text":"<p>Integrated with GitHub as a build-and-push action.</p>"},{"location":"license/","title":"License","text":"<pre><code>                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [2017-2022] [Cisco Systems Inc]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n</code></pre>"},{"location":"whats-new/","title":"What's New","text":""},{"location":"whats-new/#v0401","title":"v0.40.1","text":"<ul> <li>Support for <code>scratch</code></li> </ul> <p>Prior to v0.40.1, <code>stacker</code> did not support empty root filesystems to be used a base container image. The support has now been added which can be used to host statically built binaries.</p> <ul> <li>Support for <code>import</code>ing content into container image</li> </ul> <p>Prior to v0.40.1, copying content into a layer permanently involved bind mounting a shell such as busybox and invoking appropriate commands using the <code>run</code> directive. Now <code>import</code> directive allows for the <code>dest</code> option to achieve the same.</p> <ul> <li>For the <code>build</code> command, can specify substitute key-value pairs in a file instead of the commandline.</li> </ul> <pre><code>$ stacker build --help\nNAME:\n   stacker build - builds a new OCI image from a stacker yaml file\n\nUSAGE:\n   stacker build [command options] [arguments...]\n\nOPTIONS:\n...\n   --substitute-file value         file containing variable substitution in stackerfiles, 'FOO: bar' yaml format\n...\n</code></pre> <ul> <li>Some <code>squashfs</code> improvements</li> </ul> <p>While building squashfs layers, use <code>squashfuse_ll</code> if available which is faster.</p>"},{"location":"concepts/about/","title":"About Project Stacker","text":""},{"location":"concepts/about/#project-repository","title":"Project Repository","text":"<p>The stacker project is hosted on GitHub:</p> <p>project-stacker/stacker</p>"},{"location":"concepts/about/#sponsors","title":"Sponsors","text":"<p>Cisco Systems, Inc.</p>"},{"location":"concepts/about/#adopters","title":"Adopters","text":"<p>Cisco Systems, Inc.</p>"},{"location":"concepts/about/#presentations","title":"Presentations","text":"<ul> <li> <p>Open Source Summit (OSS) Europe 2018 </p> <ul> <li>Building OCI Images Without Privilege (EU) (PDF)</li> </ul> </li> <li> <p>Open Source Summit (OSS) North America 2018 </p> <ul> <li>Building OCI Images Without Privilege (NA) (PDF)</li> </ul> </li> <li> <p>Free and Open source Software Developers' European Meeting (FOSDEM) 2019</p> <ul> <li> <p>An Operator Centric Way to Update Application Containers (PDF)</p> </li> <li> <p>An Operator Centric Way to Update Application Containers (video)</p> </li> </ul> </li> </ul>"},{"location":"concepts/about/#license","title":"License","text":"<p>stacker is released under the Apache License, Version 2.0, and is:</p> <p>Copyright (C) 2017-2023 Cisco Systems, Inc. and contributors</p>"},{"location":"concepts/oci_image_layout/","title":"OCI Image Layout","text":"<p>Stacker is a standalone OCI-native container image builder which produces images in OCI Image Layout format.</p> <pre><code>OCI Image Layout Specification\n\n    The OCI Image Layout is the directory structure for OCI content-addressable blobs and location-addressable references (refs).\n    This layout MAY be used in a variety of transport mechanisms: archive formats (e.g. tar, zip), shared filesystem environments (e.g. nfs), or networked file fetching (e.g. http, ftp, rsync).\n</code></pre>"},{"location":"concepts/stacker_architecture/","title":"Stacker Architecture","text":"<p>The diagram below illustrates the relationship between the various directives and the internal state maintained during the image build process.</p>"},{"location":"developer_guide/CONTRIBUTING/","title":"Getting Started","text":""},{"location":"developer_guide/CONTRIBUTING/#fork-repository","title":"Fork Repository","text":"<p>Fork the stacker repository on GitHub to your personal account.</p> <pre><code>#Set golang environment\nexport GOPATH=$HOME/go\nmkdir -p $GOPATH/src/github.com/project-stacker\n\n#Get code\ngo get github.com/project-stacker/stacker\ncd $GOPATH/src/github.com/project-stacker/stacker\n\n#Track repository under your personal account\ngit config push.default nothing # Anything to avoid pushing to project-stacker/stacker by default\ngit remote rename origin project-stacker\ngit remote add $USER git@github.com:$USER/stacker.git\ngit fetch $USER\n</code></pre> <p>NOTES: Note that GOPATH can be any directory, the example above uses $HOME/go. Change $USER above to your own GitHub username.</p>"},{"location":"developer_guide/CONTRIBUTING/#build","title":"Build","text":"<p>See build instructions in the <code>stacker</code> Developer Guide.</p>"},{"location":"developer_guide/CONTRIBUTING/#using-hosts-toolchain","title":"Using host's toolchain","text":"<pre><code>make\n</code></pre>"},{"location":"developer_guide/CONTRIBUTING/#project-structure","title":"Project Structure","text":"<pre><code>.\n...\n\u251c\u2500\u2500 atomfs      # Source code contains the main atomfs logic\n\u251c\u2500\u2500 cmd         # Source code that handles commandline logic\n\u251c\u2500\u2500 container   # Source code for container management\n\u251c\u2500\u2500 embed-exec  # Source code for converting a file to a exec cmd\n\u251c\u2500\u2500 lib         # Source code contains helper routines\n\u251c\u2500\u2500 log         # Source code that handles logging\n\u251c\u2500\u2500 mount       # Source code that handles the mount logic\n\u251c\u2500\u2500 mtree       # Source code that handles the mtree logic\n\u251c\u2500\u2500 oci         # Source code that handles the OCI layout logic\n\u251c\u2500\u2500 overlay     # Source code that handles overlayfs logic\n\u251c\u2500\u2500 squashfs    # Source code that handles squashfs logic\n\u251c\u2500\u2500 storage     # Source code contains common storage code\n\u251c\u2500\u2500 test        # Source code various unit tests\n\u251c\u2500\u2500 types       # Source code that handles various object types\n</code></pre>"},{"location":"developer_guide/CONTRIBUTING/#contribute-workflow","title":"Contribute Workflow","text":"<p>PRs are always welcome, even if they only contain small fixes like typos or a few lines of code. If there is a significant effort, please document it as an issue and get a discussion going before working on it.</p> <p>Please submit a PR broken down into small changes, bit by bit. A PR with a lot features and code changes may be hard to review. It is recommended that  you submit PRs in an incremental fashion.</p> <p>Note: If you split your pull request to small changes, please make sure that  the changes that go to master do not break existing features. Otherwise, it cannot be merged until this feature is complete.</p>"},{"location":"developer_guide/CONTRIBUTING/#develop-build-and-test","title":"Develop, Build and Test","text":"<p>Write code on the new branch in your fork. The coding style used in stacker is suggested by the Golang community. See the style doc for details.</p> <p>Try to limit column width to 120 characters for both code and markdown documents such as this one.</p> <p>As we are enforcing standards set by golangci-lint, please always run a full 'make' on source code before committing your changes. This will trigger compilation, unit tests, and linting. If it reports an issue, in general, the preferred action is to fix the code. We try to enforce the guideline that code coverage does not drop as code is added or modified.</p>"},{"location":"developer_guide/CONTRIBUTING/#automated-testing-via-cicd","title":"Automated Testing (via CI/CD)","text":"<p>Once your pull request is opened, stacker will start a full CI pipeline against it that compiles, and runs unit tests and linters.</p>"},{"location":"developer_guide/CONTRIBUTING/#reporting-issues","title":"Reporting issues","text":"<p>A great way to contribute to stacker is by reporting an issue. Well-written and complete bug reports are always welcome! Please open an issue on Github and follow the template to fill in required information.</p> <p>Before opening any issue, please review existing issues to avoid submitting a duplicate. If you find a match, you can \"subscribe\" to it to get notified of updates. If you have additional helpful information about the issue, please leave a comment.</p> <p>When reporting issues, always include:</p> <p>Build environment (golang compiler, etc) Configuration files of stacker</p> <p>Log files as per configuration.</p> <p>Because the issues are open to public, when submitting the log and configuration files, be sure to remove any sensitive information, e.g. user name, password, IP address, and company name. You can replace those parts with \"REDACTED\" or other strings like \"****\".</p> <p>Be sure to include the steps to reproduce the problem, if applicable. It can help us understand and fix your issue faster.</p>"},{"location":"developer_guide/CONTRIBUTING/#documenting","title":"Documenting","text":"<p>Update the documentation if you are creating or changing features. Good documentation is as important as the code itself.</p> <p>The main location for the documentation is the website repository. The images referred to in documents can be placed in docs/img in that repo.</p> <p>Documents are written using Markdown. See Writing on GitHub for more details.</p>"},{"location":"developer_guide/CONTRIBUTING/#design-new-features","title":"Design New Features","text":"<p>You can propose new designs for existing stacker features. You can also design new features.  Please submit a proposal in GitHub issues. stacker maintainers will review this proposal as soon as possible. This is necessary to ensure consistency in the overall architecture and to avoid duplicate effort in the roadmap.</p>"},{"location":"developer_guide/building_stacker/","title":"Building and Installing Stacker","text":""},{"location":"developer_guide/building_stacker/#go-dependency","title":"Go Dependency","text":"<p>Stacker requires at least go 1.11.</p>"},{"location":"developer_guide/building_stacker/#ubuntu-2004","title":"Ubuntu 20.04","text":"<p>On Ubuntu 20.04 you can install Go using the instructions at: https://github.com/golang/go/wiki/Ubuntu</p>"},{"location":"developer_guide/building_stacker/#fedora-31","title":"Fedora 31","text":"<p>On Fedora 31 you can install Go with the following command:</p> <pre><code>sudo dnf install golang\n</code></pre>"},{"location":"developer_guide/building_stacker/#other-distributions","title":"Other Distributions","text":"<p>If Go is not already packaged for your Linux distribution, you can get the latest Go version at: https://golang.org/dl/#stable</p> <p>Go can be installed using the instructions on the official Go website at: https://golang.org/doc/install#install</p>"},{"location":"developer_guide/building_stacker/#other-dependencies","title":"Other Dependencies","text":""},{"location":"developer_guide/building_stacker/#ubuntu-2004_1","title":"Ubuntu 20.04","text":"<p>The other build dependencies can be satisfied with the following command and packages:</p> <pre><code>sudo apt install lxc-dev libacl1-dev libgpgme-dev libcap-dev libseccomp-dev\nsudo apt install libpam0g-dev libselinux-dev libssl-dev libzstd-dev libcryptsetup-dev libdevmapper-dev\n</code></pre>"},{"location":"developer_guide/building_stacker/#ubuntu-2204","title":"Ubuntu 22.04","text":"<pre><code>sudo apt install lxc-dev libacl1-dev libgpgme-dev libcap-dev libseccomp-dev\nsudo apt install libpam0g-dev libselinux-dev libssl-dev libzstd-dev libcryptsetup-dev libdevmapper-dev cryptsetup-bin pkg-config libsquashfs1 libsquashfs-dev\n</code></pre> <p>To run <code>make check</code> you will also need:</p> <pre><code>sudo apt install bats jq tree\n</code></pre> <p>umoci - https://github.com/opencontainers/umoci</p> <p>squashtool, but with a slightly different config than what is mentioned in the install guide (see below) - https://github.com/anuvu/squashfs</p> <p>Contrary to what the documentation in squashfs implies, squashtool and libsquash from squash-tools-ng need to be installed globally, as user specific path overrides are not propagated to <code>make check</code>'s test envs.</p> <p>Thus, when you reach the step install into mylocal=\"$HOME/lib\" from the squashfs guide, use the config below. You can put them at the end of your .bashrc file so you don't need to run them every time.</p> <pre><code>mylocal=\"/usr/local\"\nexport LD_LIBRARY_PATH=$mylocal/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\nexport PKG_CONFIG_PATH=$mylocal/lib/pkgconfig${PKG_CONFIG_PATH:+:$PKG_CONFIG_PATH}\n</code></pre> <p>Because the path /usr/local is owned by root, when you reach the step to run make install, you need to run it as sudo.</p> <p><code>make check</code>  requires the golangci-lint binary to be present in $GOPATH/bin</p> <p>Because there are a few tests that run with elevated privileges and use git, it will complain that the stacker folder is unsafe as it is owned by your user. To prevent that, we need to tell git to consider that folder as safe. To do this, open your git config file (.gitconfig) and add the following line with the path to your local stacker folder. Below is an example:</p> <pre><code>[safe]\n    directory = /home/chofnar/github/stacker\n</code></pre>"},{"location":"developer_guide/building_stacker/#fedora-31_1","title":"Fedora 31","text":"<p>The other build dependencies can be satisfied with the following command and packages:</p> <pre><code>sudo dnf install lxc-devel libcap-devel libacl-devel gpgme-devel\nsudo dnf install bats jq\n</code></pre>"},{"location":"developer_guide/building_stacker/#building-the-stacker-binary","title":"Building the Stacker Binary","text":"<p>Finally, once you have the build dependencies, stacker can be built with a simple <code>make</code>. The stacker binary will be output as <code>./stacker</code>.</p>"},{"location":"developer_guide/code_structure/","title":"Project Structure","text":"<pre><code>.\n...\n\u251c\u2500\u2500 atomfs      # Source code contains the main atomfs logic\n\u251c\u2500\u2500 cmd         # Source code that handles commandline logic\n\u251c\u2500\u2500 container   # Source code for container management\n\u251c\u2500\u2500 embed-exec  # Source code for converting a file to a exec cmd\n\u251c\u2500\u2500 lib         # Source code contains helper routines\n\u251c\u2500\u2500 log         # Source code that handles logging\n\u251c\u2500\u2500 mount       # Source code that handles the mount logic\n\u251c\u2500\u2500 mtree       # Source code that handles the mtree logic\n\u251c\u2500\u2500 oci         # Source code that handles the OCI layout logic\n\u251c\u2500\u2500 overlay     # Source code that handles overlayfs logic\n\u251c\u2500\u2500 squashfs    # Source code that handles squashfs logic\n\u251c\u2500\u2500 storage     # Source code contains common storage code\n\u251c\u2500\u2500 test        # Source code various unit tests\n\u251c\u2500\u2500 types       # Source code that handles various object types\n</code></pre>"},{"location":"developer_guide/lxc_usage/","title":"LXC","text":"<p>stacker uses lxc as its underlying container management library in order to achieve hermetically-sealed image builds.</p>"},{"location":"developer_guide/overlayfs_usage/","title":"OverlayFS Support","text":"<p>stacker relies on overlayFS in the Linux kernel, which should be available in kernel versions 4.x and above.</p> <p>You can also check by running the command <code>lsmod | grep overlay</code> if compiled and available as a module or if compiled inline by enabling <code>CONFIG_OVERLAY_FS</code> in the Linux kernel build configuration.</p>"},{"location":"get_started/get_stacker/","title":"Installing Stacker","text":"<p>Stacker is a single static binary tool with most of the dependencies built into  the binary. Stacker, however, depends on specific kernel capabilities and system tools to provide various features.</p> Download Stacker<pre><code>wget https://github.com/project-stacker/stacker/releases/latest/download/stacker\nchmod +x ./stacker\nsudo cp ./stacker /usr/bin/stacker\nstacker --version\nstacker check\n</code></pre>"},{"location":"get_started/get_stacker/#kernel-dependencies","title":"Kernel dependencies","text":"<p>Stacker requires overlayfs backend. That works with any kernel &gt;= 4.14.  However, for unprivileged usage, the overlayfs backend requires a new  kernel change available on all kernels &gt;= 5.8. </p>  <p>Info</p> <p>Overlayfs kernel patches required for unprivileged use:</p> <ul> <li>vfs: allow unprivileged whiteout creation - a3c751a50fe6 </li> <li>ovl: unprivieged mounts - 459c7c565ac3</li> </ul>  <p>Some distributions may have ported these patches into older versions of their kernels. For example, Ubuntu 20.04 and 22.04 kernels already have these patches.</p> <p>Stacker includes checks to ensure that it can run with all these requirements, and will fail if it can't perform a function it should be able perform.</p> Stacker Check<pre><code>stacker check &amp;&amp; echo \"stacker is ready to use!\"\n</code></pre>"},{"location":"get_started/get_stacker/#overlay-filesystem","title":"Overlay filesystem","text":"<p>An underlying overlayfs cannot back stacker because the stacker needs to create  whiteout files, and the kernel (rightfully) forbids manual creation of whiteout  files on overlay filesystems. No additional userspace dependencies are required to use the overlayfs backend.</p>  <p>Warning</p> <p>Do not use a overlayfs based filesystem as a storage for stacker root directory.</p>"},{"location":"get_started/get_stacker/#unprivileged-setup","title":"Unprivileged setup","text":"<p>Running stacker as an unprivileged user requires stacker to run as part of a <code>user</code> namespace owned by the user that executed the command. Stacker will  map <code>65k</code> user and group IDs to meet the POSIX standard. So, to run stacker, the user's <code>/etc/sub{u,g}id</code> should be configured with enough UIDs to map components correctly. This configuration can be run automatically via  <code>stacker unpriv-setup</code>.</p> Stacker unprivileged setup<pre><code>sudo stacker unpriv-setup\ncat /etc/subgid\ncat /etc/subuid\n</code></pre>"},{"location":"get_started/get_stacker/#squashfs-support","title":"Squashfs support","text":"<p>In order to generate squashfs images, stacker invokes the <code>mksquashfs</code> binary. This binary needs to be installed and available in <code>$PATH</code>.</p> Install mksquashfs on ubuntu<pre><code>sudo apt-get install -y squashfs-tools\n</code></pre>"},{"location":"get_started/hello_stacker_image/","title":"A \"Hello Stacker\" Image","text":"<p>Stacker builds OCI images using the YAML definition in a file referred to as  the Stacker file. Let's create a stacker file definition that packages a  simple \"Hello Stacker!\" script into an OCI container image.</p> Hello Stacker<pre><code>hello-stacker:\n  from:\n    type: docker\n    url: docker://zothub.io/tools/busybox:stable\n  run: |\n    mkdir -p /hello-stacker-app\n    echo 'echo \"Hello Stacker!\"' &gt; /hello-stacker-app/hello.sh\n    chmod +x /hello-stacker-app/hello.sh\n  entrypoint: /hello-stacker-app/hello.sh\n</code></pre> <p><code>hello-stacker</code>, the first key in the above YAML, builds an OCI image named hello-stacker.</p> <p>The <code>from</code> section defines that <code>hello-stacker</code> image builds on an  existing image called <code>zothub.io/tools/busybox:stable</code>, and the base image is of type  <code>docker</code> downloaded from URL <code>docker://zothub.io/tools/busybox:stable</code>.</p> <p>The <code>run</code> section defines a build script. This script is executed on the ubuntu image's root file system and creates an executable file called  <code>/hello-stacker-app/hello.sh</code>.</p> <p><code>entrypoint</code> defines that <code>/hello-stacker-app/hello.sh</code> is executed as the <code>init</code> process on creating this container by a container runtime.</p> <p>We can create the <code>hello-stacker</code> image with this input as a stacker file name <code>hello_stacker.yaml</code>.</p> <p>Hello Stacker Build<pre><code>$ stacker build -f hello_stacker.yaml\npreparing image hello-stacker...\nloading docker://zothub.io/tools/busybox:stable\nCopying blob cf92e523b49e done\nCopying config cb52c703ef done\nWriting manifest to image destination\nStoring signatures\n+ mkdir -p /hello-stacker-app\n+ echo echo \"Hello Stacker!\"\n+ chmod +x /hello-stacker-app/hello.sh\nfilesystem hello-stacker built successfully\n</code></pre> stacker build used <code>hello-stacker.yaml</code> as input, downloaded the <code>zothub.io/tools/busybox:stable</code> image from docker hub and generated an OCI image with tag <code>hello-stacker</code>. We  can verify this using <code>stacker inspect</code>:</p> Stacker Inspect<pre><code>$ stacker inspect\nhello-stacker\n        layer 0: cf92e523b49e... (30 MB, application/vnd.oci.image.layer.v1.tar+gzip)\n        layer 1: 2910d371807c... (176 B, application/vnd.oci.image.layer.v1.tar+gzip)\nAnnotations:\n  io.stackeroci.stacker.stacker_yaml: hello-stacker:\n  from:\n    type: docker\n    url: docker://zothub.io/tools/busybox:stable\n  run: |\n    mkdir -p /hello-stacker-app\n    echo 'echo \"Hello Stacker!\"' &gt; /hello-stacker-app/hello.sh\n    chmod +x /hello-stacker-app/hello.sh\n  entrypoint: /hello-stacker-app/hello.sh\n\n\nImage config:\n{\n  \"created\": \"2022-10-24T03:47:24.374578534Z\",\n  \"author\": \"stacker-dev\",\n  \"architecture\": \"amd64\",\n  \"os\": \"linux\",\n  \"config\": {\n    \"Env\": [\n      \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"\n    ],\n    \"Entrypoint\": [\n      \"/hello-stacker-app/hello.sh\"\n    ]\n  },\n  \"rootfs\": {\n    \"type\": \"layers\",\n    \"diff_ids\": [\n      \"sha256:17f623af01e277c5ffe6779af8164907de02d9af7a0e161662fc735dd64f117b\",\n      \"sha256:a33ac624796108439088267fb525f1038dccb6f6a50796a1593786a31d97a4bd\"\n    ]\n  },\n  \"history\": [\n    {\n      \"created\": \"2022-10-04T23:35:20.465021967Z\",\n      \"created_by\": \"/bin/sh -c #(nop) ADD file:6cd2e13356aa5339c1f2abd3c210a52f6ed74fae05cd61aa09f37b6a4764f65c in / \"\n    },\n    {\n      \"created\": \"2022-10-04T23:35:20.857335994Z\",\n      \"created_by\": \"/bin/sh -c #(nop)  CMD [\\\"bash\\\"]\",\n      \"empty_layer\": true\n    },\n    {\n      \"created\": \"2022-10-24T03:47:24.372946511Z\",\n      \"created_by\": \"stacker build of hello-stacker\"\n    },\n    {\n      \"created\": \"2022-10-24T03:47:24.374578534Z\",\n      \"created_by\": \"stacker build\",\n      \"author\": \"root@ins15-pp24-ru11\",\n      \"empty_layer\": true\n    }\n  ]\n}\n</code></pre> <p>Note that if we rebuild the image without any modifications to the stacker file, less things happen:</p> stacker caching<pre><code>$ stacker build -f hello_stacker.yaml\npreparing image hello-stacker...\nloading docker://zothub.io/tools/busybox:stable\nCopying blob cf92e523b49e skipped: already exists\nCopying config cb52c703ef done\nWriting manifest to image destination\nStoring signatures\nfound cached layer hello-stacker\n</code></pre> <p>Stacker will cache all inputs to the stacker file and rebuilds the image only if something changed in the stacker file. The cache and the metadata required to  track the build state live in the <code>.stacker</code> directory where the stacker command  is run. Stacker cache can be cleaned using <code>stacker clean</code> command.</p>"},{"location":"get_started/tutorial/","title":"Stacker Tutorial","text":"<p>Stacker is a tool that allows you to build OCI images in a reproducible manner, completely unprivileged. In this tutorial, we'll introduce the stacker configuration file and perform a few simple builds.</p>  <p> For this tutorial, we assume you have followed the installation instructions and your environment satisfies all runtime dependecies.</p>"},{"location":"get_started/tutorial/#your-first-stackeryaml-file","title":"Your first <code>stacker.yaml</code> file","text":"<p>The basic input to stacker is the stacker file, such as <code>stacker.yaml</code>. This YAML-format file uses <code>key:value</code> pairs to describe what the base for your OCI image should be, and what steps must be performed to construct the image. </p> <p>Let's start with one of the smallest stacker files:</p> <pre><code>    first:\n        from:\n            type: docker\n            url: docker://centos:latest\n</code></pre> <p>In this example, the key named <code>first</code> represents the name of the layer. </p>  <p> This key can have any name except <code>config</code>, which has a special usage in the stacker file. See the full documentation for stacker yaml.</p>  <p>Using the small stacker file, named <code>first.yaml</code>, we can perform a basic stacker build:</p> <pre>\n    $ stacker build -f first.yaml\n    building image first...\n    importing files...\n    Getting image source signatures\n    Copying blob sha256:5e35d10a3ebadf9d6ab606ce72e1e77f8646b2e2ff8dd3a60d4401c3e3a76f31\n     69.60 MB / 69.60 MB [=====================================================] 16s\n    Copying config sha256:44a17ce607dadfb71de41d82c75d756c2bca4db677bba99969f28de726e4411e\n     862 B / 862 B [============================================================] 0s\n    Writing manifest to image destination\n    Storing signatures\n    unpacking to /home/ubuntu/tutorial/roots/_working\n    running commands...\n    generating layer...\n    filesystem first built successfully\n</pre> <p>During the build, stacker downloaded the <code>centos:latest</code> tag from the docker hub and generated it as an OCI image with the additional <code>first</code> tag. We can verify the result by using the <code>umoci ls</code> command, which lists the tags in an image:</p> <pre>\n    $ umoci ls --layout oci\n    centos-latest\n    first\n</pre> <p>The <code>centos-latest</code> tag is the OCI tag for the base image, and <code>first</code> is the name of the image we generated.</p> <p>If we execute a rebuild at this point, fewer steps are needed:</p> <pre>\n    $ stacker build -f first.yaml\n    building image first...\n    importing files...\n    found cached layer first\n</pre> <p>The rebuild is shorter because stacker caches all of the inputs to a build, and only rebuilds the parts that change. The cache (and all of stacker's metadata) reside in the <code>/stacker</code> directory, from which you run stacker. </p>  <p> Stacker's metadata can be cleaned with <code>stacker clean</code>, which also removes its entire cache.</p>"},{"location":"get_started/tutorial/#adding-import-and-run-directives","title":"Adding <code>import</code> and <code>run</code> directives","text":"<p>At this point in our example, the only input is a base image, but what if we want to import a script to run or a config file? Consider the next stacker file example:</p> <pre><code>    first:\n        from:\n            type: docker\n            url: docker://centos:latest\n        import:\n            - config.json\n            - install.sh\n        run: |\n            mkdir -p /etc/myapp\n            cp /stacker/config.json /etc/myapp/\n            /stacker/install.sh\n</code></pre> <p>If the content of <code>install.sh</code> is \"echo hello world,\" the stacker build output will look like this:</p> <pre>\n    $ stacker build -f first.yaml\n    building image first...\n    importing files...\n    copying config.json\n    copying install.sh\n    Getting image source signatures\n    Skipping fetch of repeat blob sha256:5e35d10a3ebadf9d6ab606ce72e1e77f8646b2e2ff8dd3a60d4401c3e3a76f31\n    Copying config sha256:44a17ce607dadfb71de41d82c75d756c2bca4db677bba99969f28de726e4411e\n     862 B / 862 B [============================================================] 0s\n    Writing manifest to image destination\n    Storing signatures\n    unpacking to /home/ubuntu/tutorial/roots/_working\n    running commands...\n    running commands for first\n    + mkdir -p /etc/myapp\n    + cp /stacker/config.json /etc/myapp\n    + /stacker/install.sh\n    hello world\n    generating layer...\n    filesystem first built successfully\n</pre> <p>In this latest stacker file, we've added an <code>import</code> section, with two new directives :</p> <pre><code>    import:\n        - config.json\n        - install.sh\n</code></pre> <p>This new section imports two files into the <code>/stacker</code> directory inside the image. This directory will not be present in the final image, so you must copy any needed files from this directory into their final place in the image. Also, importing files from the web (via URLs like  http://example.com/foo.tar.gz) is supported, and these files will also be cached on disk. </p>  <p> If a file is already cached, stacker will not access the URL again. If the file at the URL changes, you must run <code>stacker build</code> with the <code>--no-cache</code> argument or you can delete the file from its cached location (in this case, <code>/stacker/imports/$target_name/foo.tar.gz</code>).</p>  <p>The other new addition in our latest stacker file example is a <code>run</code> section:</p> <pre><code>    run: |\n        mkdir -p /etc/myapp\n        cp /stacker/config.json /etc/myapp/\n        /stacker/install.sh\n</code></pre> <p>This section lists the commands that will be run in order to install and configure the image.</p> <p>Note that the build in the latest example used a cached version of the base layer again, but then rebuilt the part where you asked for commands to be run, since that is new.</p>"},{"location":"get_started/tutorial/#devbuild-containers","title":"dev/build containers","text":"<p>Finally, stacker offers \"build only\" containers, which are built but not emitted in the final OCI image. Consider this stacker file example:</p> <pre><code>    build:\n        from:\n            type: docker\n            url: docker://ubuntu:latest\n        run: |\n            apt update\n            apt install -y software-properties-common git\n            apt-add-repository -y ppa:gophers/archive\n            apt update\n            apt install -y golang-1.9\n            export PATH=$PATH:/usr/lib/go-1.9/bin\n            export GOPATH=~/go\n            mkdir -p $GOPATH/src/github.com/openSUSE\n            cd $GOPATH/src/github.com/openSUSE\n            git clone https://github.com/opencontainers/umoci\n            cd umoci\n            make umoci.static\n            cp umoci.static /\n        build_only: true\n    umoci:\n        from:\n            type: docker\n            url: docker://centos:latest\n        import: stacker://build/umoci.static\n        run: cp /stacker/umoci.static /usr/bin/umoci\n</code></pre> <p>This file builds a static version of umoci in an ubuntu container, but the final image will contain only an <code>umoci</code> tag with a statically linked version of <code>umoci</code> at <code>/usr/bin/umoci</code>. There are a few new directives to support this result:</p> <pre><code>    build_only: true\n</code></pre> <p>This line indicates that the container shouldn't be emitted in the final image, because we're only going to import something from it and we don't need the rest of it.</p> <pre><code>    import: stacker://build/umoci.static\n</code></pre> <p>This line performs the actual import. The line calls for this action: \"From a previously built stacker image called <code>build</code>, import <code>/umoci.static</code>.\"</p>"},{"location":"reference/stacker_cli/","title":"Stacker Command-Line Interface Reference","text":"stackerStacker builds OCI images stacker buildBuild a new OCI image from a stacker yaml file stacker recursive-buildFind stacker yaml files under a directory and builds all OCI layers they define stacker publishPublish OCI images previously built from one or more stacker yaml files stacker chrootRun a command in a chroot (same as <code>stacker exec</code>) stacker cleanClean up after a stacker build stacker inspectPrint the json representation of an OCI image stacker grabGrab a file from the layer's filesystem stacker unpriv-setupDo the necessary unprivileged setup for stacker build to work without root stacker gcGarbage collection of unused OCI imports/outputs snapshots stacker checkCheck that all runtime required items (like kernel features) are present stacker helpShow a list of commands or help for one command"},{"location":"reference/stacker_cli/#stacker","title":"stacker","text":"<pre><code>    NAME:\n    stacker - stacker builds OCI images\n\n    USAGE:\n    stacker [global options] command [command options] [arguments...]\n\n    VERSION:\n    stacker v0.40.1-e54a685 liblxc a330126b45c7c3b6fcf0f9ba6c1eda7bdb4e508a\n\n    COMMANDS:\n    build            builds a new OCI image from a stacker yaml file\n    recursive-build  finds stacker yaml files under a directory and builds all OCI layers they define\n    publish          publishes OCI images previously built from one or more stacker yaml files\n    chroot, exec     run a command in a chroot\n    clean            cleans up after a `stacker build`\n    inspect          print the json representation of an OCI image\n    grab             grabs a file from the layer's filesystem\n    unpriv-setup     do the necessary unprivileged setup for stacker build to work without root\n    gc               gc unused OCI imports/outputs snapshots\n    check            checks that all runtime required things (like kernel features) are present\n    help, h          Shows a list of commands or help for one command\n\n    GLOBAL OPTIONS:\n    --stacker-dir value   set the directory for stacker's cache (default: \".stacker\")\n    --oci-dir value       set the directory for OCI output (default: \"oci\")\n    --roots-dir value     set the directory for the rootfs output (default: \"roots\")\n    --config value        stacker config file with defaults (default: \"/users/mishield/.config/stacker/conf.yaml\")\n    --debug               enable stacker debug mode\n    -q, --quiet           silence all logs\n    --log-file value      log to a file instead of stderr\n    --log-timestamp       whether to log a timestamp prefix\n    --storage-type value  storage type (must be \"overlay\", left for compatibility) (default: \"overlay\")\n    --no-progress         disable progress when downloading container images or files\n    --help, -h            show help\n    --version, -v         print the version\n</code></pre>"},{"location":"reference/stacker_cli/#stacker-build","title":"stacker build","text":"<pre><code>    NAME:\n    stacker build - builds a new OCI image from a stacker yaml file\n\n    USAGE:\n    stacker build [command options] [arguments...]\n\n    OPTIONS:\n    --no-cache                      don't use the previous build cache\n    --substitute value              variable substitution in stackerfiles, FOO=bar format\n    --substitute-file value         file containing variable substitution in stackerfiles, 'FOO: bar' yaml format\n    --on-run-failure value          command to run inside container if run fails (useful for inspection)\n    --shell-fail                    exec /bin/sh inside the container if run fails (alias for --on-run-failure=/bin/sh)\n    --layer-type value              set the output layer type (supported values: tar, squashfs); can be supplied multiple times (default: \"tar\")\n    --no-squashfs-verity            do not append dm-verity data to squashfs archives\n    --require-hash                  require all remote imports to have a hash provided in stackerfiles\n    --order-only                    show the build order without running the actual build\n    --annotations-namespace value   set OCI annotations namespace in the OCI image manifest (default: \"io.stackeroci\")\n    --stacker-file value, -f value  the input stackerfile (default: \"stacker.yaml\")\n</code></pre>"},{"location":"reference/stacker_cli/#stacker-recursive-build","title":"stacker recursive-build","text":"<pre><code>    NAME:\n    stacker recursive-build - finds stacker yaml files under a directory and builds all OCI layers they define\n\n    USAGE:\n    stacker recursive-build [command options] [arguments...]\n\n    OPTIONS:\n    --no-cache                              don't use the previous build cache\n    --substitute value                      variable substitution in stackerfiles, FOO=bar format\n    --substitute-file value                 file containing variable substitution in stackerfiles, 'FOO: bar' yaml format\n    --on-run-failure value                  command to run inside container if run fails (useful for inspection)\n    --shell-fail                            exec /bin/sh inside the container if run fails (alias for --on-run-failure=/bin/sh)\n    --layer-type value                      set the output layer type (supported values: tar, squashfs); can be supplied multiple times (default: \"tar\")\n    --no-squashfs-verity                    do not append dm-verity data to squashfs archives\n    --require-hash                          require all remote imports to have a hash provided in stackerfiles\n    --order-only                            show the build order without running the actual build\n    --annotations-namespace value           set OCI annotations namespace in the OCI image manifest (default: \"io.stackeroci\")\n    --stacker-file-pattern value, -p value  regex pattern to use when searching for stackerfile paths (default: \"\\\\/stacker.yaml$\")\n    --search-dir value, -d value            directory under which to search for stackerfiles to build (default: \".\")\n</code></pre>"},{"location":"reference/stacker_cli/#stacker-publish","title":"stacker publish","text":"<pre><code>    NAME:\n    stacker publish - publishes OCI images previously built from one or more stacker yaml files\n\n    USAGE:\n    stacker publish [command options] [arguments...]\n\n    OPTIONS:\n    --stacker-file value, -f value          the input stackerfile (default: \"stacker.yaml\")\n    --stacker-file-pattern value, -p value  regex pattern to use when searching for stackerfile paths (default: \"\\\\/stacker.yaml$\")\n    --search-dir value, -d value            directory under which to search for stackerfiles to publish\n    --url value                             url where to publish the OCI images\n    --username value                        username for the registry where the OCI images are published\n    --password value                        password for the registry where the OCI images are published\n    --skip-tls                              skip tls verify on upstream registry\n    --tag value                             tag to be used when publishing\n    --substitute value                      variable substitution in stackerfiles, FOO=bar format\n    --show-only                             show the images to be published without actually publishing them\n    --force                                 force publishing the images present in the OCI layout even if they should be rebuilt\n    --layer-type value                      set the output layer type (supported values: tar, squashfs); can be supplied multiple times (default: \"tar\")\n</code></pre>"},{"location":"reference/stacker_cli/#stacker-chroot-exec","title":"stacker chroot, exec","text":"<pre><code>    NAME:\n    stacker chroot - run a command in a chroot\n\n    USAGE:\n    stacker chroot [command options] [tag] [cmd]\n\n    &lt;tag&gt; is the built tag in the stackerfile to chroot to, or the first tag if\n    none is specified.\n\n    &lt;cmd&gt; is the command to run, or /bin/sh if none is specified. To specify cmd,\n    you must specify a tag.\n\n    OPTIONS:\n    --stacker-file value, -f value  the input stackerfile (default: \"stacker.yaml\")\n    --substitute value              variable substitution in stackerfiles, FOO=bar format\n</code></pre>"},{"location":"reference/stacker_cli/#stacker-clean","title":"stacker clean","text":"<pre><code>    NAME:\n    stacker clean - cleans up after a `stacker build`\n\n    USAGE:\n    stacker clean [command options] [arguments...]\n\n    OPTIONS:\n    --all  no-op; this used to do soemthing, and is left in for compatibility\n</code></pre>"},{"location":"reference/stacker_cli/#stacker-inspect","title":"stacker inspect","text":"<pre><code>    NAME:\n    stacker inspect - print the json representation of an OCI image\n\n    USAGE:\n    stacker inspect [tag]\n\n    &lt;tag&gt; is the tag in the stackerfile to inspect. If none is supplied, inspect\n    prints the information on all tags.\n</code></pre>"},{"location":"reference/stacker_cli/#stacker-grab","title":"stacker grab","text":"<pre><code>    NAME:\n    stacker grab - grabs a file from the layer's filesystem\n\n    USAGE:\n    stacker grab &lt;tag&gt;:&lt;path&gt;\n\n    &lt;tag&gt; is the tag in a built stacker image to extract the file from.\n\n    &lt;path&gt; is the path to extract (relative to /) in the image's rootfs.\n</code></pre>"},{"location":"reference/stacker_cli/#stacker-unpriv-setup","title":"stacker unpriv-setup","text":"<pre><code>    NAME:\n    stacker unpriv-setup - do the necessary unprivileged setup for stacker build to work without root\n\n    USAGE:\n    stacker unpriv-setup [command options] [arguments...]\n\n    OPTIONS:\n    --uid value       the user to do setup for (defaults to $SUDO_UID from env)\n    --gid value       the group to do setup for (defaults to $SUDO_GID from env)\n    --username value  the username to do setup for (defaults to $SUDO_USER from env)\n</code></pre>"},{"location":"reference/stacker_cli/#stacker-gc","title":"stacker gc","text":"<pre><code>    NAME:\n    stacker gc - gc unused OCI imports/outputs snapshots\n\n    USAGE:\n    stacker gc [arguments...]\n</code></pre>"},{"location":"reference/stacker_cli/#stacker-check","title":"stacker check","text":"<pre><code>    NAME:\n    stacker check - checks that all runtime required things (like kernel features) are present\n\n    USAGE:\n    stacker check [arguments...]\n</code></pre>"},{"location":"reference/stacker_cli/#stacker-help","title":"stacker help","text":"<pre><code>    NAME:\n        - Shows a list of commands or help for one command\n\n    USAGE:\n        [command]\n</code></pre>"},{"location":"reference/stacker_file/","title":"The <code>stacker.yaml</code> file","text":"<p>When doing a <code>stacker build</code>, the behavior of stacker is specified by the yaml directives below. In addition to these, stacker allows variable substitions of several forms. For example, a line like:</p> <pre><code>$ONE ${{TWO}} ${{THREE:3}}\n</code></pre> <p>When run with <code>stacker build --substitute ONE=1 --substitute TWO=2</code> is processed in stacker as:</p> <pre><code>1 2 3\n</code></pre> <p>That is, variables of the form <code>$FOO</code> or <code>${FOO}</code> are supported, and variables with <code>${FOO:default}</code> a default value will evaluate to their default if not specified on the command line. It is an error to specify a <code>${FOO}</code> style without a default; to make the default an empty string, use <code>${FOO:}</code>.</p> <p>In addition to substitutions provided on the command line, the following variables are also available with their values from either command line flags or stacker-config file.</p> <pre><code>STACKER_STACKER_DIR config name 'stacker_dir', cli flag '--stacker-dir'-\nSTACKER_ROOTFS_DIR  config name 'rootfs_dir', cli flag '--roots-dir'\nSTACKER_OCI_DIR     config name 'oci_dir', cli flag '--oci-dir'\n</code></pre> <p>The stacker build environment has the following environment variables available for reference:</p> <ul> <li> <p><code>STACKER_LAYER_NAME</code>: the name of the layer being built.  <code>STACKER_LAYER_NAME</code>     will be <code>my-build</code> when the <code>run</code> section below is executed.</p> <pre><code>my-build:\n  run: echo \"Your layer is ${STACKER_LAYER_NAME}\"\n</code></pre> </li> </ul>"},{"location":"reference/stacker_file/#from","title":"<code>from</code>","text":"<p>The <code>from</code> directive describes the base image that stacker will start from. It takes the form:</p> <pre><code>from:\n    type: $type\n    url: $url\n    tag: $tag\n    insecure: true\n</code></pre> <p>Some directives are irrelevant depending on the type. Supported types are:</p> <p><code>docker</code>: <code>url</code> is required, <code>insecure</code> is optional. When <code>insecure</code> is specified, stacker attempts to connect via http instead of https to the Docker Hub.</p> <p><code>tar</code>: <code>url</code> is required, everything else is ignored.</p> <p><code>oci</code>: <code>url</code> is required, of the form <code>path:tag</code>. This uses the OCI image at <code>url</code> (which may be a local path).</p> <p><code>built</code>: <code>tag</code> is required, everything else is ignored. <code>built</code> bases this layer on a previously specified layer in the stacker file.</p> <p><code>scratch</code>: which is an empty rootfs and can be used to host statically built binaries.</p>"},{"location":"reference/stacker_file/#import","title":"<code>import</code>","text":"<p>The <code>import</code> directive describes what files should be made available in <code>/stacker</code> during the <code>run</code> phase. There are three forms of importing supported today:</p> <pre><code>/path/to/file\n</code></pre> <p>Will import a file or directory from the local filesystem. If the file or directory changes between stacker builds, it will be hashed and the new file will be imported on subsequent builds.</p> <pre><code>http://example.com/foo.tar.gz\n</code></pre> <p>Will import foo.tar.gz and make it available in <code>/stacker</code>. Note that stacker will NOT update this file unless the cache is cleared, to avoid excess network usage. That means that updates after the first time stacker downloads the file will not be reflected.</p> <pre><code>stacker://$name/path/to/file\n</code></pre> <p>Will grab /path/to/file from the previously built layer <code>$name</code>.</p>"},{"location":"reference/stacker_file/#import-hash","title":"<code>import hash</code>","text":"<p>The <code>import</code> directive also supports specifying the hash(sha256sum) of import source, for all the three forms presented above, for example: <pre><code>import:\n  - path: config.json\n    hash: f55af805b012017bc....\n  - path: http://example.com/foo.tar.gz\n    hash: b458dfd63e7883a64....\n  - path: stacker://$name/path/to/file\n    hash: f805b012017bc769a....\n</code></pre> Before copying the file it will check if the requested hash matches the actual one.</p> <p><code>stacker build</code> supports the flag <code>--require-flag</code> which checks that all http(s) remote imports have an hash in all stacker YAMLs.</p> <p>This new import mode can be combined with the old one, for example: <pre><code>import:\n  - path: \"config.json\n    hash: \"BEEFcafeaaaaAAAA....\"\n  - /path/to/file\n</code></pre></p>"},{"location":"reference/stacker_file/#import-dest","title":"<code>import dest</code>","text":"<p>The <code>import</code> directive also supports specifying the destination path (specified by <code>dest</code>) in the resulting container image, where the source file (specified by <code>path</code>) will be copyied to, for example: <pre><code>import:\n  - path: config.json\n    dest: /\n</code></pre></p>"},{"location":"reference/stacker_file/#overlay_dirs","title":"<code>overlay_dirs</code>","text":"<p>This directive works only with OverlayFS backend storage.</p> <p>The <code>overlay_dirs</code> directive describes the directories (content) from the host that should be available in the container's filesystem. It preserves all file/dirs attributes but no owner or group.</p> <p><pre><code>overlay_dirs:\n  - source: /path/to/directory\n    dest: /usr/local/          ## optional arg, default is '/'\n  - source: /path/to/directory2\n</code></pre> This example will result in all the files/dirs from the host's /path/to/directory  to be available under container's /usr/local/ and all the files/dirs from the host's /path/to/directory2 to be available under container's /</p>"},{"location":"reference/stacker_file/#environment-labels-working_dir-volumes-cmd-entrypoint-user","title":"<code>environment</code>, <code>labels</code>, <code>working_dir</code>, <code>volumes</code>, <code>cmd</code>, <code>entrypoint</code>, <code>user</code>","text":"<p>These correspond exactly to the similarly named bits in the OCI image config spec, and are available for users to pass things through to the runtime environment of the image.</p>"},{"location":"reference/stacker_file/#generate_labels","title":"<code>generate_labels</code>","text":"<p>The <code>generate_labels</code> entry is similar to <code>run</code> in that it contains a list of commands to run inside the generated rootfs. It runs after the <code>run</code> section is done, and its mutations to the filesystem are not recorded, except in one case <code>/oci-labels</code>. <code>/oci-labels</code> is a special directory where this code can write a file, and the name of the file will be the OCI label name, and the content will be the label content.</p>"},{"location":"reference/stacker_file/#build_env-and-build_env_passthrough","title":"<code>build_env</code> and <code>build_env_passthrough</code>","text":"<p>By default, environment variables do not pass through (pollute) the build environment.</p> <p><code>build_env</code>: this is a dictionary with environment variable definitions.    their values will be present in the build's environment.</p> <p><code>build_env_passthrough</code>: This is a list of regular expressions that work as a filter on which environment variables should be passed through from the current env into the container.  To let all variables through simply set <code>build_env_passthrough</code>: <code>[\".*\"]</code></p> <p>If <code>build_env_passthrough</code> is not set, then the default value is to allow through proxy variables <code>HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, http_proxy, https_proxy, ftp_proxy</code>.</p> <p>Values in the <code>build_env</code> override values passed through via</p>"},{"location":"reference/stacker_file/#full_command","title":"<code>full_command</code>","text":"<p>Because of the odd behavior of <code>cmd</code> and <code>entrypoint</code> (and the inherited nature of these from previous stacker layers), <code>full_command</code> provides a way to set the full command that will be executed in the image, clearing out any previous <code>cmd</code> and <code>entrypoint</code> values that were set in the image.</p>"},{"location":"reference/stacker_file/#build_only","title":"<code>build_only</code>","text":"<p><code>build_only</code>: indicates whether or not to include this layer in the final OCI image. This can be useful in conjunction with an import from this layer in another image, if you want to isolate the build environment for a binary but not include all of its build dependencies.</p>"},{"location":"reference/stacker_file/#binds","title":"<code>binds</code>","text":"<p><code>binds</code>: specifies bind mounts from the host to the container. There are two formats:</p> <pre><code>binds:\n    - /foo/bar -&gt; /bar/baz\n- /zomg\n</code></pre> <p>The first one binds /foo/bar to /bar/baz, and the second host /zomg to container /zomg.</p> <p>Right now there is no awareness of change for any of these bind mounts, so --no-cache should be used to re-build if the content of the bind mount has changed.</p>"},{"location":"reference/stacker_file/#config","title":"<code>config</code>","text":"<p><code>config</code> key is a special type of entry in the root in the <code>stacker.yaml</code> file. It cannot contain a layer definition, it is used to provide configuration applicable for building all the layers defined in this file. For example,</p> <pre><code>config:\n    prerequisites:\n        - ../folder2/stacker.yaml\n        - ../folder3/stacker.yaml\n</code></pre>"},{"location":"reference/stacker_file/#prerequisites","title":"<code>prerequisites</code>","text":"<p>If the <code>prerequisites</code> list is present under the <code>config</code> key, stacker will make sure to build all the layers in the stacker.yaml files found at the paths contained in the list. This way stacker supports building multiple stacker.yaml files in the correct order.</p> <p>In this particular case the parent folder of the current folder, let's call it <code>parent</code>, has 3 subfolders <code>folder1</code>, <code>folder2</code> and <code>folder3</code>, each containing a <code>stacker.yaml</code> file. The example <code>config</code> above is in <code>parent/folder1/stacker.yaml</code>.</p> <p>When <code>stacker build -f parent/folder1/stacker.yaml</code> is invoked, stacker would search for the other two stacker.yaml files and build them first, before building the stacker.yaml specified in the command line.</p>"},{"location":"reference/stacker_file/#annotations","title":"<code>annotations</code>","text":"<p><code>annotations</code> is a user-specified key value map that will be included in the final OCI image. Note that these annotations are included in the image manifest itself and not as part of the index.json.</p> <pre><code>annotations:\n  a.b.c.key: abc_val\n  p.q.r.key: pqr_val\n</code></pre> <p>While <code>config</code> section supports a similar <code>labels</code>, it is more pertitent to the image runtime. On the other hand, <code>annotations</code> is intended to be image-specific metadata aligned with the annotations in the image spec.</p>"},{"location":"reference/stacker_file/#os","title":"os","text":"<p>The <code>os</code> key value is a user-specified string indicating which operating system this image is being built for. Examples include <code>linux</code> and <code>darwin</code>. This directive is optional and defaults to the host operating system if not specified.</p>"},{"location":"reference/stacker_file/#arch","title":"arch","text":"<p>The <code>arch</code> key value is a user-specified string indicating which machine architecture this image is being built for. Examples include <code>amd64</code> and <code>arm64</code>. This directive is optional and defaults to the host machine architecture if not specified.</p>"},{"location":"user_guide/annotation_support/","title":"Additing Annotations","text":"<p>In the stacker yaml file, <code>annotations</code> is a user-specified key value map that is included in the final OCI image. Note that these annotations are included in the image manifest itself and not as part of the index.json.</p> <pre><code>annotations:\n  a.b.c.key: abc_val\n  p.q.r.key: pqr_val\n</code></pre> <p>While <code>config</code> section supports a similar <code>labels</code>, it is more pertitent to the image runtime. On the other hand, <code>annotations</code> is intended to be image-specific metadata aligned with the annotations in the image spec.</p>"},{"location":"user_guide/build_cache/","title":"Build Cache","text":"<p>A build cache with snapshot support is maintained throughout the build process in order to store intermediate build artifacts and avoid unnecessary rebuilds. Furthermore, you can also avoid rebuilding layers across many stacker build invocations by preserving this build cache.</p>"},{"location":"user_guide/build_code/","title":"Producing Images From Compiled/Built Code","text":"<p>A common first step before building a container image is to build your code in a consistent environment. Stacker provides a hermetically sealed environment in a build-only container to produce the binaries and other artifacts required for the container image. Whether you are building a container image or not, it is a  good idea to use stacker's container-based builds to produce your binaries, especially when you need a consistent build environment for all the developers  collaborating on the same project.</p>"},{"location":"user_guide/build_code/#go-code-example","title":"Go Code Example","text":"<p>As an example, let's build a simple go file using stacker:</p> Go build using stacker<pre><code>cat &gt; \"hello_stacker.go\" &lt;&lt; EOF\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello Stacker!\")\n}\nEOF\n\ncat &gt; \"go_build.stacker.yaml\" &lt;&lt; EOF\ngo-build-hello-stacker:\n  from:\n    type: docker\n    url: docker://zothub.io/c3/ubuntu/go-devel-amd64:1.19.2\n  import:\n    - ./hello_stacker.go\n  build_only: true\n  run: |\n    # Source Go toolchain env\n    . /etc/profile\n\n    # Setup Go ENV\n    mkdir -p /go\n    export GOPATH=/go\n    mkdir -p /go/src\n    cd /go/src\n\n    # Copy source code to go path\n    cp /stacker/hello_stacker.go .\n\n    # Build code\n    go build -o hello_stacker hello_stacker.go\n\n    # Test code\n    ./hello_stacker\nEOF\n\nstacker build -f go_build.stacker.yaml\npreparing image hello-go-stacker...\nusing cached copy of /dev/shm/ravi/hello_stacker.go\nloading docker://zothub.io/c3/ubuntu/go-devel-amd64:1.19.2\nCopying blob b900f44d647a skipped: already exists\nCopying config 3ece5b544e done\nWriting manifest to image destination\nStoring signatures\ncache miss because layer definition was changed\n+ . /etc/profile\n+ export 'HOME=/go'\n+ export 'GOROOT=/opt/go'\n+ export 'PATH=/opt/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\n+ mkdir -p /tmp/go/cache\n+ export 'GOCACHE=/tmp/go/cache'\n+ mkdir -p /go\n+ export 'GOPATH=/go'\n+ mkdir -p /go/src\n+ cd /go/src\n+ cp /stacker/hello_stacker.go .\n+ go build -o hello_stacker hello_stacker.go\n+ ./hello_stacker\nHello Stacker!\n</code></pre> <p>The above script creates a go file called <code>hello_stacker.go</code>, then uses a go  development container from <code>zothub.io/c3/ubuntu/go-devel-amd:1.19.2</code> to build  <code>hello_stacker.go</code>.</p> <p>Let's look at details of the stacker file sections used:</p>    Stacker file Keyword Description     <code>from</code> specifies the base container to be used for this build   <code>import</code> import file from host into the build container   <code>build_only</code> mark this as a build container to avoid layer creation   <code>run</code> build script to execute    <p>Note <code>cp /stacker/hello_stacker.go .</code> in the <code>run</code> script. Stacker bind mounts all the imported files under a special read-only directory <code>/stacker</code>. This directory can be used in the <code>run</code> script to access the host mounted files in the build script.</p>"},{"location":"user_guide/build_container_image/","title":"Multi-Stage Build","text":"<p>Usually, developers use a two-stage build process to build a container image.  In the first stage, make the binary for the container image, and in the second stage, build the runtime container image, including that binary. To accomplish this, stacker \"build only\" container builds the required binary and does not generate the corresponding OCI layer. Then copy this binary into the RFS of the  runtime image such that the final container has only the required binary.</p> Two-stage container image build<pre><code>cat &gt; \"hello_stacker.go\" &lt;&lt; EOF\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello Stacker!\")\n}\nEOF\n\ncat &gt; \"hello.stacker.yaml\" &lt;&lt; EOF\nbuild-hello-stacker:\n  from:\n    type: docker\n    url: docker://zothub.io/c3/ubuntu/go-devel-amd64:1.19.2\n  import:\n    - ./hello_stacker.go\n  build_only: true\n  run: |\n    # Source Go toolchain env\n    . /etc/profile\n\n    # Setup Go ENV\n    mkdir -p /go\n    export GOPATH=/go\n    mkdir -p /go/src\n    cd /go/src\n\n    # Copy source code to go path\n    cp /stacker/hello_stacker.go .\n\n    # Build a static go binary\n    go build -ldflags=\"-extldflags=-static\" -o hello_stacker.static hello_stacker.go\n\n    cp hello_stacker.static /\nhello:\n  from:\n    type: docker\n    url: docker://zothub.io/tools/busybox:stable\n  import:\n    - stacker://build-hello-stacker/hello_stacker.static\n  run: |\n    cp /stacker/hello_stacker.static /hello_stacker\n    chmod +x /hello_stacker\n    /hello_stacker # test\nEOF\n\nstacker build -f hello.stacker.yaml\npreparing image build-hello-stacker...\ncopying /dev/shm/ravi/hello_stacker.go\nloading docker://zothub.io/c3/ubuntu/go-devel-amd64:1.19.2\nCopying blob b900f44d647a done\nCopying config 3ece5b544e done\nWriting manifest to image destination\nStoring signatures\n+ . /etc/profile\n+ export 'HOME=/go'\n+ export 'GOROOT=/opt/go'\n+ export 'PATH=/opt/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\n+ mkdir -p /tmp/go/cache\n+ export 'GOCACHE=/tmp/go/cache'\n+ mkdir -p /go\n+ export 'GOPATH=/go'\n+ mkdir -p /go/src\n+ cd /go/src\n+ cp /stacker/hello_stacker.go .\n+ go build '-ldflags=-extldflags=-static' -o hello_stacker.static hello_stacker.go\n+ cp hello_stacker.static /\npreparing image hello...\nloading docker://zothub.io/tools/busybox:stable\nCopying blob f5b7ce95afea done\nCopying config 74c82eccc6 done\nWriting manifest to image destination\nStoring signatures\n+ cp /stacker/hello_stacker.static /hello_stacker\n+ chmod +x /hello_stacker\n+ /hello_stacker\nHello Stacker!\nfilesystem hello built successfully\n</code></pre>  <p>Info</p> <p><code>stacker://build-hello-stacker/hello_stacker.static</code> import statement imports the specific binary file from the <code>build-hello-stacker</code> that is present in the build cache</p>  <p>Lets verify that the hello layer has /hello_stacker file:</p> stacker chroot<pre><code>stacker chroot -f hello.stacker.yaml hello\nThis chroot is temporary, any changes will be destroyed when it exits.\n/ # ls -al /hello_stacker\n-rwxrwxr-x    1 root     root       1809694 Oct 26 01:27 /hello_stacker\n/ # exit\n</code></pre>"},{"location":"user_guide/build_environment/","title":"Hermetically-sealed Build Environment","text":"<p>Stacker builds container images in a canonically defined environment, allowing  stacker to guarantee repeatable builds by reproducing the same environment for  all the builds for a given version of the stacker file.</p>"},{"location":"user_guide/build_environment/#runtime-environment","title":"Runtime Environment","text":"<p>Except for the term and proxy settings, none of the host environment variables leak into the stacker build environment. The <code>run</code> section of your  build script can depend on these environment variables to perform the build.</p> <p>Let's examine the shell environment variables that stacker exposes to the build script in the run section of your stacker file: </p> Stacker Build Environment<pre><code>cat &gt; env_stacker.yaml &lt;&lt; EOF\nenv-stacker:\n  from:\n    type: docker\n    url: docker://zothub.io/tools/busybox:stable\n  run: |\n    env\n  build_only: true\nEOF\n\nstacker build -f env_stacker.yaml\npreparing image env-stacker...\nloading docker://zothub.io/tools/busybox:stable\nCopying blob f5b7ce95afea skipped: already exists\nCopying config 74c82eccc6 done\nWriting manifest to image destination\nStoring signatures\ncache miss because layer definition was changed\n+ env\nHTTPS_PROXY=http://173.36.224.109:8080\nno_proxy=localhost,127.0.0.1,localaddress,.localdomain.com,.cisco.com\nSHLVL=1\nNO_PROXY=localhost,127.0.0.1,localaddress,.localdomain.com,.cisco.com\ncontainer=lxc\nhttps_proxy=http://173.36.224.109:8080\nTERM=screen-256color\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nSTACKER_LAYER_NAME=env-stacker\nPWD=/\n</code></pre> <p>Note that only <code>HTTPS_PROXY</code>, <code>https_proxy</code>, <code>NO_PROXY</code>, <code>no_proxy</code>, and <code>TERM</code> are imported from the host, all other variables are standard shell variables.</p>"},{"location":"user_guide/build_environment/#root-file-system-rfs","title":"Root File System (RFS)","text":"<p>Stacker creates a root file system defined by the layer in the <code>from</code> section and launches the build script in the <code>run</code> section using this file system. Stacker expects a \"sane\" file system in the base container so that it can execute <code>sh</code> to  implement the <code>run</code> section.</p> <p>Let's examine the root file system that stacker exposes to the <code>run</code> script in the following example:</p> Build RFS<pre><code>cat &gt; rfs_stacker.yaml &lt;&lt; EOF\nrfs-stacker:\n  from:\n    type: docker\n    url: docker://zothub.io/tools/busybox:stable\n  run: |\n    ls -al /\n    find /etc\n    which cat\n  build_only: true\nEOF\n\nstacker build -f rfs_stacker.yaml\npreparing image rfs-stacker...\nloading docker://zothub.io/tools/busybox:stable\nCopying blob f5b7ce95afea skipped: already exists\nCopying config 74c82eccc6 done\nWriting manifest to image destination\nStoring signatures\n+ ls -al /\ntotal 0\ndrwxr-xr-x    1 root     root           120 Oct 25 18:30 .\ndrwxr-xr-x    1 root     root           120 Oct 25 18:30 ..\ndrwxr-xr-x    2 root     root          8080 Oct  3 22:04 bin\ndrwxr-xr-x    4 root     root           340 Oct 25 18:30 dev\ndrwxr-xr-x    1 root     root            60 Oct 25 18:30 etc\ndrwxr-xr-x    2 nobody   nobody          40 Oct  3 22:04 home\ndr-xr-xr-x 2299 nobody   nobody           0 Oct 25 18:30 proc\ndrwx------    2 root     root            40 Oct  3 22:04 root\ndrwxr-xr-x    2 root     root            60 Oct 25 18:30 stacker\ndr-xr-xr-x   13 nobody   nobody           0 Sep 22 22:12 sys\ndrwxrwxrwt    2 root     root            40 Oct  3 22:04 tmp\ndrwxr-xr-x    3 root     root            60 Oct  3 22:04 usr\ndrwxr-xr-x    4 root     root            80 Oct  3 22:04 var\n+ find /etc\n/etc\n/etc/shadow\n/etc/passwd\n/etc/network\n/etc/network/if-up.d\n/etc/network/if-pre-up.d\n/etc/network/if-post-down.d\n/etc/network/if-down.d\n/etc/localtime\n/etc/group\n/etc/resolv.conf\n+ which cat\n/bin/cat\n</code></pre> <p>The <code>docker://zothub.io/tools/busybox:stable</code> container defines the above file system, which has all the necessary utilities like /bin/cat and a basic system configuration required to operate most of the Linux utilities.</p>"},{"location":"user_guide/build_environment/#networking-setup","title":"Networking Setup","text":"<p>Stacker builds the container images in the host network namespace. It bind  mounts the host's /etc/resolv.conf into the build container's root file system  to allow for correct DNS resolution as defined by the host. Finally, stacker  re-exports the proxy settings to the environment to enable proxy-based access to any artifacts required to build the container image.</p> <p>Let's examine the networking setup that stacker exposes to the <code>run</code> script in the following example:</p> Networking setup<pre><code>cat &gt; network_stacker.yaml &lt;&lt; EOF\nnetwork-stacker:\n  from:\n    type: docker\n    url: docker://zothub.io/tools/busybox:stable\n  run: |\n    echo \"HTTPS_PROXY=$HTTPS_PROXY\"\n    cat /etc/resolv.conf\n    ip addr\n  build_only: true\nEOF\n\nstacker build -f network_stacker.yaml\npreparing image network-stacker...\nloading docker://zothub.io/tools/busybox:stable\nCopying blob f5b7ce95afea skipped: already exists\nCopying config 74c82eccc6 done\nWriting manifest to image destination\nStoring signatures\n+ echo HTTPS_PROXY=http://173.36.224.109:8080\nHTTPS_PROXY=http://173.36.224.109:8080\n+ cat /etc/resolv.conf\n# This is /run/systemd/resolve/stub-resolv.conf managed by man:systemd-resolved(8).\n# Do not edit.\n#\n# This file might be symlinked as /etc/resolv.conf. If you're looking at\n# /etc/resolv.conf and seeing this text, you have followed the symlink.\n#\n# This is a dynamic resolv.conf file for connecting local clients to the\n# internal DNS stub resolver of systemd-resolved. This file lists all\n# configured search domains.\n#\n# Run \"resolvectl status\" to see details about the uplink DNS servers\n# currently in use.\n#\n# Third party programs should typically not access this file directly, but only\n# through the symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a\n# different way, replace this symlink by a static file or a different symlink.\n#\n# See man:systemd-resolved.service(8) for details about the supported modes of\n# operation for /etc/resolv.conf.\n\nnameserver 127.0.0.53\noptions edns0 trust-ad\nsearch cisco.com insieme.local\n+ ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n2: enp97s0f0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq qlen 1000\n    link/ether 3c:fd:fe:7f:27:a0 brd ff:ff:ff:ff:ff:ff\n3: enp97s0f1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq qlen 1000\n    link/ether 3c:fd:fe:7f:27:a1 brd ff:ff:ff:ff:ff:ff\n4: enp97s0f2: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq qlen 1000\n    link/ether 3c:fd:fe:7f:27:a2 brd ff:ff:ff:ff:ff:ff\n5: enp97s0f3: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq qlen 1000\n    link/ether 3c:fd:fe:7f:27:a3 brd ff:ff:ff:ff:ff:ff\n6: enp1s0f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq qlen 1000\n    link/ether b4:96:91:a4:44:d4 brd ff:ff:ff:ff:ff:ff\n    inet 172.20.61.165/24 brd 172.20.61.255 scope global enp1s0f0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::b696:91ff:fea4:44d4/64 scope link\n       valid_lft forever preferred_lft forever\n7: enp1s0f1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq qlen 1000\n    link/ether b4:96:91:a4:44:d5 brd ff:ff:ff:ff:ff:ff\n8: lxcbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue qlen 1000\n    link/ether 00:16:3e:00:00:00 brd ff:ff:ff:ff:ff:ff\n    inet 10.0.3.1/24 brd 10.0.3.255 scope global lxcbr0\n       valid_lft forever preferred_lft forever\n9: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue\n    link/ether 02:42:30:0d:77:ad brd ff:ff:ff:ff:ff:ff\n    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0\n       valid_lft forever preferred_lft forever\n</code></pre> <p>Since stacker is only used for building images, this is safe and intuitive for  users on corporate networks with complicated proxy and other setups. However,  it does mean that container packaging that expects to be able to modify things in <code>/sys</code> will fail since /sys is bind mounted from the host's <code>/sys</code>. <code>sysfs</code> cannot be mounted in a network namespace that a user doesn't own.</p>"},{"location":"user_guide/debugging/","title":"Debugging","text":"<p>The first step to trying to find a bug in stacker is to run it with --debug. This gives you a stack trace from where (at least in stacker's code) the error originated via github.com/pkg/errors.</p> <p>Sometimes it is useful to write a small reproducer in <code>test/</code>, and run it with:</p> <pre><code>make check TEST=myreproducer.bats\n</code></pre>"},{"location":"user_guide/debugging/#overlayfs-layer-issues","title":"Overlayfs / layer issues","text":"<p><code>--debug</code> also shows you the overlay arguments it is sending to LXC. Note that the build overlay filesystem never exists in the host mount namespace, but is created by liblxc in the child namespace. Sometimes it can be useful to take these overlay arguments and split up the lowerdirs:</p> <pre><code>./stacker/stacker_layers/.roots/sha256_f8e46c301da6347e78057d8fe48a6bbd8fc0cab213d47825f5c0c0646f542b6b/overlay\n./stacker/stacker_layers/.roots/sha256_7eb8e296d351fe6d0c87fea979b305e2b1f19548d99f9aee4b8030b596f02efd/overlay\n./stacker/stacker_layers/.roots/sha256_ca379e914166030218007477a7b9cfd0ca3dd554c58e2401c58c634fac9182f8/overlay\n</code></pre> <p>and look through each one (top to bottom, as the overlay stack would present) in order to see what's going on.</p>"},{"location":"user_guide/debugging/#debugging-lxc","title":"Debugging LXC","text":"<p>If things are really bad, you may end up wading through liblxc. With <code>--debug</code>, stacker will also try and render any liblxc ERRORs to stdout, but sometimes it can be useful to see a full liblxc trace log. This is available in <code>$(--stacker-dir)/lxc.log</code> for the last run.</p> <p>If you get even more in the weeds, you may need to build your own liblxc with debug statements. Thankfully, everything is statically linked so this is fairly easy to test locally, as long as your host liblxc can build stacker:</p> <pre><code>make LXC_CLONE_URL=https://github.com/tych0/lxc LXC_BRANCH=my-debug-branch\n</code></pre> <p>Stacker links against this through a convoluted mechanism: it builds a static C program in <code>/cmd/lxc-wrapper/</code> that takes a few relevant arguments about what mode to drive liblxc in. Stacker uses the <code>go-embed</code> mechanism to embed the resulting statically linked binary, and then resolves and executes it at runtime via the code in <code>/embed-exec</code>. The reason for all this indirection vs. linking against something directly is that the kernel does not allow multithreaded programs to unshare user namespaces. Since the go runtime spawns many threads for GC and various other tasks, go code cannot directly unshare a user namespace (one wonders, then, why this was the language chosen for runc, lxd, etc...). A previous implementation (the one in lxd) was to use some <code>__attribute__((constructor))</code> nonsense and hope for the best, but it doesn't work in all cases, and go-embed allows for librar-ization of stacker code if someone else wants to use it eventually. See 8fa336834f31 (\"container: move to go-embed for re-exec of C code\") for details on that approach.</p>"},{"location":"user_guide/debugging/#overlay-storage-layout","title":"Overlay storage layout","text":"<p>The storage parent directory is whatever is specified to stacker via <code>--roots-dir</code>. Each layer is extracted into a <code>sha256_$hash/overlay</code> directory, which is then sewn together via overlayfs. At the top level, for a layer called <code>foo</code>, there are two directories: <code>foo/rootfs</code>, and <code>foo/overlay</code>. During the build, <code>foo</code>'s rootfs is mounted inside the container as <code>foo/rootfs</code>, with the overlay <code>upperdir=foo/overlay</code>. This way, whatever filesystem mutations the <code>foo</code> layer's <code>run:</code> section performs end up in <code>foo/overlay</code>.</p> <p>After the <code>run:</code> section, stacker generates whatever layers the user requested from this, creates <code>sha256_$hash/overlay</code> dirs with the contents (if two layer types were converted, then the hash of the squashfs output will just be a symlink to the tar layer's directory to save space), and <code>foo/overlay_metadata.json</code> will be updated to reflect these new outputs, for use when e.g. <code>foo</code> is a dependency of some other layer <code>bar</code>.</p> <p>Note that there is currently one wart. In a stacker file like:</p> <pre><code>foo:\n  from:\n    type: docker\n    url: docker://ubuntu:latest\n  build_only: true\n  run: |\n    dd if=/dev/random of=/bigfile bs=1M count=1000\nbar:\n  from:\n    type: built\n    tag: foo\n  run: |\n    rm /bigfile\n</code></pre> <p>The final image for <code>bar</code> will actually contain a layer with <code>/bigfile</code> in it, because the <code>foo</code> layer's mutations are generated independently of <code>bar</code>'s. Some clever userspace overlay collapsing could be done here to remove this wart, though.</p>"},{"location":"user_guide/dependency_builds/","title":"Chained Builds With Dependency Tracking","text":"<p>You can split image build directives over multiple files and chain them.</p> <p>If the <code>prerequisites</code> list is present under the <code>config</code> key, stacker will make sure to build all the layers in the stacker.yaml files found at the paths contained in the list. This way stacker supports building multiple stacker.yaml files in the correct order.</p> <p>In this particular case the parent folder of the current folder, let's call it <code>parent</code>, has 3 subfolders <code>folder1</code>, <code>folder2</code> and <code>folder3</code>, each containing a <code>stacker.yaml</code> file. The example <code>config</code> above is in <code>parent/folder1/stacker.yaml</code>.</p> <p>When <code>stacker build -f parent/folder1/stacker.yaml</code> is invoked, stacker would search for the other two stacker.yaml files and build them first, before building the stacker.yaml specified in the command line.</p>"},{"location":"user_guide/grab_image_content/","title":"Grab Content From Built Images","text":"<p>After an image is built, you can grab a file from the built image. This is useful to inspect the file or its contents to ensure the build process has completed properly.</p> <pre><code>NAME:\n   stacker grab - grabs a file from the layer's filesystem\n\nUSAGE:\n   stacker grab &lt;tag&gt;:&lt;path&gt;\n\n&lt;tag&gt; is the tag in a built stacker image to extract the file from.\n\n&lt;path&gt; is the path to extract (relative to /) in the image's rootfs.\n</code></pre>"},{"location":"user_guide/image_chroot/","title":"Chrooting Into Built Images","text":"<p>After an image is built, you can run a command in a chroot in that built image.</p> <pre><code>NAME:\n   stacker chroot - run a command in a chroot\n\nUSAGE:\n   stacker chroot [command options] [tag] [cmd]\n\n&lt;tag&gt; is the built tag in the stackerfile to chroot to, or the first tag if\nnone is specified.\n\n&lt;cmd&gt; is the command to run, or /bin/sh if none is specified. To specify cmd,\nyou must specify a tag.\n\nOPTIONS:\n   --stacker-file value, -f value  the input stackerfile (default: \"stacker.yaml\")\n   --substitute value              variable substitution in stackerfiles, FOO=bar format\n</code></pre>"},{"location":"user_guide/inspect_images/","title":"Inspecting Built Images","text":"<p>All built images are stored in OCI Image Layout, and you can inspect the JSON representation of an OCI image after it is built.</p> <pre><code>NAME:\n   stacker inspect - print the json representation of an OCI image\n\nUSAGE:\n   stacker inspect [tag]\n\n&lt;tag&gt; is the tag in the stackerfile to inspect. If none is supplied, inspect\nprints the information on all tags.\n</code></pre>"},{"location":"user_guide/publish_images/","title":"Publishing images","text":"<p>After building the image, you can publish the image to an OCI Distribution Spec conformant registry.</p> <pre><code>NAME:\n   stacker publish - publishes OCI images previously built from one or more stacker yaml files\n\nUSAGE:\n   stacker publish [command options] [arguments...]\n\nOPTIONS:\n   --stacker-file value, -f value          the input stackerfile (default: \"stacker.yaml\")\n   --stacker-file-pattern value, -p value  regex pattern to use when searching for stackerfile paths (default: \"\\\\/stacker.yaml$\")\n   --search-dir value, -d value            directory under which to search for stackerfiles to publish\n   --url value                             url where to publish the OCI images\n   --username value                        username for the registry where the OCI images are published\n   --password value                        password for the registry where the OCI images are published\n   --skip-tls                              skip tls verify on upstream registry\n   --tag value                             tag to be used when publishing\n   --substitute value                      variable substitution in stackerfiles, FOO=bar format\n   --show-only                             show the images to be published without actually publishing them\n   --force                                 force publishing the images present in the OCI layout even if they should be rebuilt\n   --layer-type value                      set the output layer type (supported values: tar, squashfs); can be supplied multiple times (default: \"tar\")\n</code></pre>"},{"location":"user_guide/scratch_image/","title":"Bootsrapping From Other Images","text":"<p>There are a couple of cases where it may be useful to build a layer from scratch. For example to derive a new base install of an OS or to build a \"tarball\" type image which just carries data and will not actually be run by a container runtime.</p> <p>The way to accomplish this in stacker is to use a build only layer (i.e. a layer that does not get emitted into the final OCI image, perhaps containing assets or something that will be used by the final container).</p> <p>The best way to accomplish this is as follows:</p> <pre><code>build:\n    from:\n        type: docker\n        url: docker://ubuntu:latest\n    run: |\n        touch /tmp/first\n        touch /tmp/second\n        tar -C /tmp -cv -f /contents.tar first second\n    build_only: true\ncontents:\n    from:\n        type: tar\n        url: stacker://build/contents.tar\n</code></pre> <p>Or e.g. to bootstrap a base layer for CentoOS 7:</p> <pre><code>build:\n    from:\n        type: docker\n        url: docker://ubuntu:latest\n    run: |\n        yum -y --installroot=/rootfs --nogpgcheck install\n        tar -C rootfs -zcf /rootfs.tar .\n    build_only: true\ncontents:\n    from:\n        type: tar\n        url: stacker://build/rootfs.tar\n</code></pre> <p>These work by creating the base for the system in a build container with all the utilities available needed to manipulate that base, and then asking stacker to create a layer based on this tarball, without actually running anything inside of the layer (which means e.g. absence of a shell or libc or whatever is fine).</p> <p>Another way to accomplish something similar is to use a  distroless layer:</p> <pre><code>build:\n    from:\n        type: docker\n        url: docker://ubuntu:latest\n    binds:\n        - /tmp/dir_to_overlay -&gt; /dir_to_overlay\n    run: |\n        touch /dir_to_overlay/binaryfile\n    build_only: true\ncontents:\n    from:\n        type: docker\n        url: docker://zothub.io/project-stacker/c3/base\n    overlay_dirs:\n        - source: /tmp/dir_to_overlay\n          dest: /dir_to_overlay\n</code></pre> <p>You can use the first layer as a build env, and copy your binary to a  bind-mounted folder. Use overlay_dirs with that same folder to have the binary  in the distroless layer.</p>"},{"location":"user_guide/template_substitution/","title":"Template Variable Substitution","text":"<p>When doing a <code>stacker build</code>, the behavior of stacker is specified by the yaml directives below. In addition to these, stacker allows variable substitions of several forms. For example, a line like:</p> <pre><code>$ONE ${{TWO}} ${{THREE:3}}\n</code></pre> <p>When run with <code>stacker build --substitute ONE=1 --substitute TWO=2</code> is processed in stacker as:</p> <pre><code>1 2 3\n</code></pre> <p>That is, variables of the form <code>$FOO</code> or <code>${FOO}</code> are supported, and variables with <code>${FOO:default}</code> a default value will evaluate to their default if not specified on the command line. It is an error to specify a <code>${FOO}</code> style without a default; to make the default an empty string, use <code>${FOO:}</code>.</p>"}]}